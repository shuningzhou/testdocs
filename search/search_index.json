{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Overview"},{"location":"fixedmath/","text":"","title":"Fixedmath"},{"location":"physics/","text":"","title":"Physics"},{"location":"frameSync/importantClass/frameSyncAgent/","text":"FrameSyncAgent \u00b6 Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } } Events \u00b6 The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game. OnFrameSyncEngineCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. OnFrameSyncGameCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. OnCollectLocalPlayerInputs \u00b6 Called every frame to collect the inputs of the local player.","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#framesyncagent","text":"Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#events","text":"The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game.","title":"Events"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncenginecreated","text":"Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method.","title":"OnFrameSyncEngineCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncgamecreated","text":"Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method.","title":"OnFrameSyncGameCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#oncollectlocalplayerinputs","text":"Called every frame to collect the inputs of the local player.","title":"OnCollectLocalPlayerInputs"},{"location":"home/installation/","text":"Welcome to FrameSync \u00b6 Installation \u00b6 https://github.com/shuningzhou/upmtest.git https://github.com/shuningzhou/framesyncup.git","title":"Installation"},{"location":"home/installation/#welcome-to-framesync","text":"","title":"Welcome to FrameSync"},{"location":"home/installation/#installation","text":"https://github.com/shuningzhou/upmtest.git https://github.com/shuningzhou/framesyncup.git","title":"Installation"},{"location":"tutorial/pong/ballManager/","text":"Ball Manager \u00b6 Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Kickoff \u00b6 The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball. Handle player ready input \u00b6 Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready. Boundary Check \u00b6 Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores. Reset the ball \u00b6 Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#ball-manager","text":"Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#kickoff","text":"The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball.","title":"Kickoff"},{"location":"tutorial/pong/ballManager/#handle-player-ready-input","text":"Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready.","title":"Handle player ready input"},{"location":"tutorial/pong/ballManager/#boundary-check","text":"Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores.","title":"Boundary Check"},{"location":"tutorial/pong/ballManager/#reset-the-ball","text":"Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Reset the ball"},{"location":"tutorial/pong/buildGame/","text":"Building the Game \u00b6 64-bit architecture \u00b6 FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit. Windowed mode \u00b6 Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 . Entering the debug PlayerUID \u00b6 Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#building-the-game","text":"","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#64-bit-architecture","text":"FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit.","title":"64-bit architecture"},{"location":"tutorial/pong/buildGame/#windowed-mode","text":"Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 .","title":"Windowed mode"},{"location":"tutorial/pong/buildGame/#entering-the-debug-playeruid","text":"Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Entering the debug PlayerUID"},{"location":"tutorial/pong/collectInput/","text":"Collecting Player Inputs \u00b6 OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/collectInput/#collecting-player-inputs","text":"OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/configEngine/","text":"Configuring the FrameSyncEngine \u00b6 OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring FrameSyncEngine"},{"location":"tutorial/pong/configEngine/#configuring-the-framesyncengine","text":"OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring the FrameSyncEngine"},{"location":"tutorial/pong/configGame/","text":"Configuring the FrameSyncGame \u00b6 OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring FrameSyncGame"},{"location":"tutorial/pong/configGame/#configuring-the-framesyncgame","text":"OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring the FrameSyncGame"},{"location":"tutorial/pong/connectToDebugServer/","text":"Connecting to the Debug Server \u00b6 Start scene \u00b6 You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build. Adding UI elements \u00b6 You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection MyGameServerConnection \u00b6 Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"Connecting to Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#connecting-to-the-debug-server","text":"","title":"Connecting to the Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#start-scene","text":"You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build.","title":"Start scene"},{"location":"tutorial/pong/connectToDebugServer/#adding-ui-elements","text":"You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection","title":"Adding UI elements"},{"location":"tutorial/pong/connectToDebugServer/#mygameserverconnection","text":"Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"MyGameServerConnection"},{"location":"tutorial/pong/createAgent/","text":"Creating FrameSyncAgent \u00b6 You will create an empty GameObject to house your customized FrameSyncAgent . MyFrameSyncAgent \u00b6 Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#creating-framesyncagent","text":"You will create an empty GameObject to house your customized FrameSyncAgent .","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#myframesyncagent","text":"Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"MyFrameSyncAgent"},{"location":"tutorial/pong/debugServer/","text":"Debug Server \u00b6 FrameSync comes with a debug server that helps you test and debug your game on your local machines. Install \u00b6 You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer Launch the server \u00b6 Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#debug-server","text":"FrameSync comes with a debug server that helps you test and debug your game on your local machines.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#install","text":"You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer","title":"Install"},{"location":"tutorial/pong/debugServer/#launch-the-server","text":"Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Launch the server"},{"location":"tutorial/pong/offline/","text":"Playing Offline \u00b6 Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/offline/#playing-offline","text":"Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/online/","text":"Online FrameSyncAgent \u00b6 You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field to the script offline to control online/offline mode easily in the inspector C# public bool offline = false ; Updating the OnFrameSyncEngineCreated method \u00b6 Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); SetTickInterval ( tickInterval ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } } Updating the OnFrameSyncGameCreated method \u00b6 Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing. Updating the OnCollectLocalPlayerInputs method \u00b6 Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#online-framesyncagent","text":"You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field to the script offline to control online/offline mode easily in the inspector C# public bool offline = false ;","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#updating-the-onframesyncenginecreated-method","text":"Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); SetTickInterval ( tickInterval ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } }","title":"Updating the OnFrameSyncEngineCreated method"},{"location":"tutorial/pong/online/#updating-the-onframesyncgamecreated-method","text":"Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing.","title":"Updating the OnFrameSyncGameCreated method"},{"location":"tutorial/pong/online/#updating-the-oncollectlocalplayerinputs-method","text":"Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Updating the OnCollectLocalPlayerInputs method"},{"location":"tutorial/pong/overview/","text":"","title":"Overview"},{"location":"tutorial/pong/paddleMovement/","text":"Paddle Movement \u00b6 Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } } FrameSyncUpdate \u00b6 Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#paddle-movement","text":"Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } }","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#framesyncupdate","text":"Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"FrameSyncUpdate"},{"location":"tutorial/pong/paddleOwner/","text":"Paddle Owner \u00b6 Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } FrameSyncDataInitialize \u00b6 The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#paddle-owner","text":"Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#framesyncdatainitialize","text":"The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"FrameSyncDataInitialize"},{"location":"tutorial/pong/paddlePosition/","text":"Paddle Position Data \u00b6 Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Importing \u00b6 Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value. Exporting \u00b6 Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#paddle-position-data","text":"Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#importing","text":"Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value.","title":"Importing"},{"location":"tutorial/pong/paddlePosition/#exporting","text":"Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Exporting"},{"location":"tutorial/pong/parallel2d/","text":"Physics 2D \u00b6 FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller . Rigidbodies \u00b6 Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move Creating the ball \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject. Creating the paddles \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) . Creating the walls \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) . Setting up the camera \u00b6 Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 . Final touch \u00b6 You can change the color of the sprite to your liking. The scene should look like.","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#physics-2d","text":"FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller .","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#rigidbodies","text":"Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move","title":"Rigidbodies"},{"location":"tutorial/pong/parallel2d/#creating-the-ball","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject.","title":"Creating the ball"},{"location":"tutorial/pong/parallel2d/#creating-the-paddles","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) .","title":"Creating the paddles"},{"location":"tutorial/pong/parallel2d/#creating-the-walls","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) .","title":"Creating the walls"},{"location":"tutorial/pong/parallel2d/#setting-up-the-camera","text":"Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 .","title":"Setting up the camera"},{"location":"tutorial/pong/parallel2d/#final-touch","text":"You can change the color of the sprite to your liking. The scene should look like.","title":"Final touch"},{"location":"tutorial/pong/staticFrameSyncBehaviour/","text":"StaticFrameSyncBehaviour \u00b6 FrameSync managed updates \u00b6 StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method. FrameSync managed data \u00b6 When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data. Which GameObject should have a StaticFrameSyncBehaviour? \u00b6 You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them. Adding the StaticFrameSyncBehaviour componennt \u00b6 Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour . Assign the StaticFrameSyncBehaviourID \u00b6 You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#staticframesyncbehaviour","text":"","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-updates","text":"StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method.","title":"FrameSync managed updates"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-data","text":"When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data.","title":"FrameSync managed data"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#which-gameobject-should-have-a-staticframesyncbehaviour","text":"You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them.","title":"Which GameObject should have a StaticFrameSyncBehaviour?"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#adding-the-staticframesyncbehaviour-componennt","text":"Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour .","title":"Adding the StaticFrameSyncBehaviour componennt"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#assign-the-staticframesyncbehaviourid","text":"You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"Assign the StaticFrameSyncBehaviourID"},{"location":"tutorial/pong/viewFrame/","text":"Frame Information \u00b6 The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods. Export frame info for PaddlePositionData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); } Export frame info for PaddleOwnerData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); } Export frame info for BallManager \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); } Reset the debug server \u00b6 You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#frame-information","text":"The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddlepositiondata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); }","title":"Export frame info for PaddlePositionData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddleownerdata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); }","title":"Export frame info for PaddleOwnerData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-ballmanager","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); }","title":"Export frame info for BallManager"},{"location":"tutorial/pong/viewFrame/#reset-the-debug-server","text":"You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Reset the debug server"}]}