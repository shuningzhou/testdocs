{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Overview"},{"location":"fixedmath/ffloat/","text":"","title":"Ffloat"},{"location":"fixedmath/fixedmath/","text":"A C# fixed point math library for vector and matrix computation. This library is designed to match the Unity Mathf class as well as the Unity vector and matrix types. FixedMath Unity Math FMath Mathf FFloat float FVector2 Vector2 FVector3 Vector3 FVector4 Vector4 FMatrix4x4 Matrix4x4 FQuaternion Quaternion","title":"Overview"},{"location":"fixedmath/fmath/","text":"Description \u00b6 A collection of common math functions. Static Properties Description Mathf FMath Deg2Rad Degrees-to-radians conversion constant (Read Only). Epsilon A tiny floating point value (Read Only). 1 Infinity A representation of positive infinity (Read Only). 2 NegativeInfinity A representation of negative infinity (Read Only). 3 PI The well-known 3.14159265358979... value (Read Only). Rad2Deg Radians-to-degrees conversion constant (Read Only). Static Methods Description Mathf FMath Abs Returns the absolute value of f. Acos Returns the arc-cosine of f - the angle in radians whose cosine is f. Approximately Compares two floating point values and returns true if they are similar. Asin Returns the arc-sine of f - the angle in radians whose sine is f. Atan Returns the arc-tangent of f - the angle in radians whose tangent is f. Atan2 Returns the angle in radians whose Tan is y/x. Ceil Returns the smallest integer greater to or equal to f. CeilToInt Returns the smallest integer greater to or equal to f. Clamp Clamps the given value between the given minimum float and maximum float values. Returns the given value if it is within the min and max range. Clamp01 Clamps value between 0 and 1 and returns value. ClosestPowerOfTwo Returns the closest power of two value. CorrelatedColorTemperatureToRGB Convert a color temperature in Kelvin to RGB color. Cos Returns the cosine of angle f. DeltaAngle Calculates the shortest difference between two given angles given in degrees. Exp Returns e raised to the specified power. FloatToHalf Encode a floating point value into a 16-bit representation. Floor Returns the largest integer smaller than or equal to f. FloorToInt Returns the largest integer smaller to or equal to f. GammaToLinearSpace Converts the given value from gamma (sRGB) to linear color space. HalfToFloat Convert a half precision float to a 32-bit floating point value. InverseLerp Calculates the linear parameter t that produces the interpolant value within the range [a, b]. IsPowerOfTwo Returns true if the value is power of two. Lerp Linearly interpolates between a and b by t. LerpAngle Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees. LerpUnclamped Linearly interpolates between a and b by t with no limit to t. LinearToGammaSpace Converts the given value from linear to gamma (sRGB) color space. Log Returns the logarithm of a specified number in a specified base. Log10 Returns the base 10 logarithm of a specified number. Max Returns largest of two or more values. Min Returns the smallest of two or more values. MoveTowards Moves a value current towards target. MoveTowardsAngle Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees. NextPowerOfTwo Returns the next power of two that is equal to, or greater than, the argument. PerlinNoise Generate 2D Perlin noise. PingPong PingPong returns a value that will increment and decrement between the value 0 and length. Pow Returns f raised to power p. Repeat Loops the value t, so that it is never larger than length and never smaller than 0. Round Returns f rounded to the nearest integer. RoundToInt Returns f rounded to the nearest integer. Sign Returns the sign of f. Sin Returns the sine of angle f. SmoothDamp Gradually changes a value towards a desired goal over time. SmoothDampAngle Gradually changes an angle given in degrees towards a desired goal angle over time. SmoothStep Interpolates between min and max with smoothing at the limits. Sqrt Returns square root of f. Tan Returns the tangent of angle f in radians. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9","title":"FMath"},{"location":"fixedmath/fmath/#description","text":"A collection of common math functions. Static Properties Description Mathf FMath Deg2Rad Degrees-to-radians conversion constant (Read Only). Epsilon A tiny floating point value (Read Only). 1 Infinity A representation of positive infinity (Read Only). 2 NegativeInfinity A representation of negative infinity (Read Only). 3 PI The well-known 3.14159265358979... value (Read Only). Rad2Deg Radians-to-degrees conversion constant (Read Only). Static Methods Description Mathf FMath Abs Returns the absolute value of f. Acos Returns the arc-cosine of f - the angle in radians whose cosine is f. Approximately Compares two floating point values and returns true if they are similar. Asin Returns the arc-sine of f - the angle in radians whose sine is f. Atan Returns the arc-tangent of f - the angle in radians whose tangent is f. Atan2 Returns the angle in radians whose Tan is y/x. Ceil Returns the smallest integer greater to or equal to f. CeilToInt Returns the smallest integer greater to or equal to f. Clamp Clamps the given value between the given minimum float and maximum float values. Returns the given value if it is within the min and max range. Clamp01 Clamps value between 0 and 1 and returns value. ClosestPowerOfTwo Returns the closest power of two value. CorrelatedColorTemperatureToRGB Convert a color temperature in Kelvin to RGB color. Cos Returns the cosine of angle f. DeltaAngle Calculates the shortest difference between two given angles given in degrees. Exp Returns e raised to the specified power. FloatToHalf Encode a floating point value into a 16-bit representation. Floor Returns the largest integer smaller than or equal to f. FloorToInt Returns the largest integer smaller to or equal to f. GammaToLinearSpace Converts the given value from gamma (sRGB) to linear color space. HalfToFloat Convert a half precision float to a 32-bit floating point value. InverseLerp Calculates the linear parameter t that produces the interpolant value within the range [a, b]. IsPowerOfTwo Returns true if the value is power of two. Lerp Linearly interpolates between a and b by t. LerpAngle Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees. LerpUnclamped Linearly interpolates between a and b by t with no limit to t. LinearToGammaSpace Converts the given value from linear to gamma (sRGB) color space. Log Returns the logarithm of a specified number in a specified base. Log10 Returns the base 10 logarithm of a specified number. Max Returns largest of two or more values. Min Returns the smallest of two or more values. MoveTowards Moves a value current towards target. MoveTowardsAngle Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees. NextPowerOfTwo Returns the next power of two that is equal to, or greater than, the argument. PerlinNoise Generate 2D Perlin noise. PingPong PingPong returns a value that will increment and decrement between the value 0 and length. Pow Returns f raised to power p. Repeat Loops the value t, so that it is never larger than length and never smaller than 0. Round Returns f rounded to the nearest integer. RoundToInt Returns f rounded to the nearest integer. Sign Returns the sign of f. Sin Returns the sine of angle f. SmoothDamp Gradually changes a value towards a desired goal over time. SmoothDampAngle Gradually changes an angle given in degrees towards a desired goal angle over time. SmoothStep Interpolates between min and max with smoothing at the limits. Sqrt Returns square root of f. Tan Returns the tangent of angle f in radians. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9","title":"Description"},{"location":"fixedmath/fmatrix4x4/","text":"Description \u00b6 A standard 4x4 transformation matrix. Static Properties Description Matrix4x4 FMatrix4x4 identity Returns the identity matrix (Read Only). zero Returns a matrix with all elements set to zero (Read Only). Properties Description Matrix4x4 FMatrix4x4 decomposeProjection This property takes a projection matrix and returns the six plane coordinates that define a projection frustum. determinant The determinant of the matrix. (Read Only) inverse The inverse of this matrix. (Read Only) isIdentity Checks whether this is an identity matrix. (Read Only) lossyScale Attempts to get a scale value from the matrix. (Read Only) rotation Attempts to get a rotation quaternion from this matrix. this[int,int] Access element at [row, column]. transpose Returns the transpose of this matrix (Read Only). Public Methods Description Matrix4x4 FMatrix4x4 GetColumn Get a column of the matrix. GetRow Returns a row of the matrix. MultiplyPoint Transforms a position by this matrix (generic). MultiplyPoint3x4 Transforms a position by this matrix (fast). MultiplyVector Transforms a direction by this matrix. SetColumn Sets a column of the matrix. SetRow Sets a row of the matrix. SetTRS Sets this matrix to a translation, rotation and scaling matrix. ToString Returns a formatted string for this matrix. TransformPlane Returns a plane that is transformed in space. ValidTRS Checks if this matrix is a valid transform matrix. Static Methods Description Matrix4x4 FMatrix4x4 Frustum This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in. Inverse3DAffine Computes the inverse of a 3D affine matrix. LookAt Create a \"look at\" matrix. Ortho Create an orthogonal projection matrix. Perspective Create a perspective projection matrix. Rotate Creates a rotation matrix. Scale Creates a scaling matrix. Translate Creates a translation matrix. TRS Creates a translation, rotation and scaling matrix. Operators Description Matrix4x4 FMatrix4x4 operator * Multiplies two matrices.","title":"FMatrix4x4"},{"location":"fixedmath/fmatrix4x4/#description","text":"A standard 4x4 transformation matrix. Static Properties Description Matrix4x4 FMatrix4x4 identity Returns the identity matrix (Read Only). zero Returns a matrix with all elements set to zero (Read Only). Properties Description Matrix4x4 FMatrix4x4 decomposeProjection This property takes a projection matrix and returns the six plane coordinates that define a projection frustum. determinant The determinant of the matrix. (Read Only) inverse The inverse of this matrix. (Read Only) isIdentity Checks whether this is an identity matrix. (Read Only) lossyScale Attempts to get a scale value from the matrix. (Read Only) rotation Attempts to get a rotation quaternion from this matrix. this[int,int] Access element at [row, column]. transpose Returns the transpose of this matrix (Read Only). Public Methods Description Matrix4x4 FMatrix4x4 GetColumn Get a column of the matrix. GetRow Returns a row of the matrix. MultiplyPoint Transforms a position by this matrix (generic). MultiplyPoint3x4 Transforms a position by this matrix (fast). MultiplyVector Transforms a direction by this matrix. SetColumn Sets a column of the matrix. SetRow Sets a row of the matrix. SetTRS Sets this matrix to a translation, rotation and scaling matrix. ToString Returns a formatted string for this matrix. TransformPlane Returns a plane that is transformed in space. ValidTRS Checks if this matrix is a valid transform matrix. Static Methods Description Matrix4x4 FMatrix4x4 Frustum This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in. Inverse3DAffine Computes the inverse of a 3D affine matrix. LookAt Create a \"look at\" matrix. Ortho Create an orthogonal projection matrix. Perspective Create a perspective projection matrix. Rotate Creates a rotation matrix. Scale Creates a scaling matrix. Translate Creates a translation matrix. TRS Creates a translation, rotation and scaling matrix. Operators Description Matrix4x4 FMatrix4x4 operator * Multiplies two matrices.","title":"Description"},{"location":"fixedmath/fquaternion/","text":"Description \u00b6 Quaternions are used to represent rotations. Static Properties Description Quaternion FQuaternion identity The identity rotation (Read Only). Properties Description Quaternion FQuaternion eulerAngles Returns or sets the euler angle representation of the rotation. normalized Returns this quaternion with a magnitude of 1 (Read Only). this[int] Access the x, y, z, w components using [0], [1], [2], [3] respectively. w W component of the Quaternion. Do not directly modify quaternions. x X component of the Quaternion. Don't modify this directly unless you know quaternions inside out. y Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out. z Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out. Constructors Description Quaternion FQuaternion Quaternion Constructs new Quaternion with given x,y,z,w components. FQuaternion Constructs new Quaternion with given x,y,z,w components. Public Methods Description Quaternion FMaFQuaternionth Set Set x, y, z and w components of an existing Quaternion. SetFromToRotation Creates a rotation which rotates from fromDirection to toDirection. SetLookRotation Creates a rotation with the specified forward and upwards directions. ToAngleAxis Converts a rotation to angle-axis representation (angles in degrees). ToString Returns a formatted string of the Quaternion. Static Methods Description Quaternion FQuaternion Angle Returns the angle in degrees between two rotations a and b. AngleAxis Creates a rotation which rotates angle degrees around axis. Dot The dot product between two rotations. Euler Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order. FromToRotation Creates a rotation which rotates from fromDirection to toDirection. Inverse Returns the Inverse of rotation. Lerp Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1]. LerpUnclamped Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped. LookRotation Creates a rotation with the specified forward and upwards directions. Normalize Converts this quaternion to one with the same orientation but with a magnitude of 1. RotateTowards Rotates a rotation from towards to. Slerp Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1]. SlerpUnclamped Spherically interpolates between a and b by t. The parameter t is not clamped. Operators Description Quaternion FQuaternion operator * Combines rotations lhs and rhs. operator == Are two quaternions equal to each other?","title":"FQuaternion"},{"location":"fixedmath/fquaternion/#description","text":"Quaternions are used to represent rotations. Static Properties Description Quaternion FQuaternion identity The identity rotation (Read Only). Properties Description Quaternion FQuaternion eulerAngles Returns or sets the euler angle representation of the rotation. normalized Returns this quaternion with a magnitude of 1 (Read Only). this[int] Access the x, y, z, w components using [0], [1], [2], [3] respectively. w W component of the Quaternion. Do not directly modify quaternions. x X component of the Quaternion. Don't modify this directly unless you know quaternions inside out. y Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out. z Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out. Constructors Description Quaternion FQuaternion Quaternion Constructs new Quaternion with given x,y,z,w components. FQuaternion Constructs new Quaternion with given x,y,z,w components. Public Methods Description Quaternion FMaFQuaternionth Set Set x, y, z and w components of an existing Quaternion. SetFromToRotation Creates a rotation which rotates from fromDirection to toDirection. SetLookRotation Creates a rotation with the specified forward and upwards directions. ToAngleAxis Converts a rotation to angle-axis representation (angles in degrees). ToString Returns a formatted string of the Quaternion. Static Methods Description Quaternion FQuaternion Angle Returns the angle in degrees between two rotations a and b. AngleAxis Creates a rotation which rotates angle degrees around axis. Dot The dot product between two rotations. Euler Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order. FromToRotation Creates a rotation which rotates from fromDirection to toDirection. Inverse Returns the Inverse of rotation. Lerp Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1]. LerpUnclamped Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped. LookRotation Creates a rotation with the specified forward and upwards directions. Normalize Converts this quaternion to one with the same orientation but with a magnitude of 1. RotateTowards Rotates a rotation from towards to. Slerp Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1]. SlerpUnclamped Spherically interpolates between a and b by t. The parameter t is not clamped. Operators Description Quaternion FQuaternion operator * Combines rotations lhs and rhs. operator == Are two quaternions equal to each other?","title":"Description"},{"location":"fixedmath/fvector2/","text":"Description \u00b6 Representation of 2D vectors and points. Static Properties Description Vector2 FVector2 down Shorthand for writing Vector2(0, -1). left Shorthand for writing Vector2(-1, 0). negativeInfinity Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector2(1, 1). positiveInfinity Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector2(1, 0). up Shorthand for writing Vector2(0, 1). zero Shorthand for writing Vector2(0, 0). Properties Description Vector2 FVector2 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x or y component using [0] or [1] respectively. x X component of the vector. y Y component of the vector. Constructors Description Vector2 FVector2 Vector2 Constructs a new vector with given x, y components. FVector2 Constructs a new vector with given x, y components. Public Methods Description Vector2 FVector2 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x and y components of an existing Vector2. ToString Returns a formatted string for this vector. Static Methods Description Vector2 FVector2 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Perpendicular Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up. Reflect Reflects a vector off the vector defined by a normal. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector2 FVector2 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector2 Converts a Vector3 to a Vector2. Vector3 Converts a Vector2 to a Vector3. Vector2 Converts(explicit) a FVector2 to a Vector2. FVector2 Converts(explicit) a FVector3 to a FVector2. FVector2 Converts(explicit) a Vector2 to a FVector2. FVector2 Converts(explicit) a Vector3 to a FVector2.","title":"FVector2"},{"location":"fixedmath/fvector2/#description","text":"Representation of 2D vectors and points. Static Properties Description Vector2 FVector2 down Shorthand for writing Vector2(0, -1). left Shorthand for writing Vector2(-1, 0). negativeInfinity Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector2(1, 1). positiveInfinity Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector2(1, 0). up Shorthand for writing Vector2(0, 1). zero Shorthand for writing Vector2(0, 0). Properties Description Vector2 FVector2 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x or y component using [0] or [1] respectively. x X component of the vector. y Y component of the vector. Constructors Description Vector2 FVector2 Vector2 Constructs a new vector with given x, y components. FVector2 Constructs a new vector with given x, y components. Public Methods Description Vector2 FVector2 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x and y components of an existing Vector2. ToString Returns a formatted string for this vector. Static Methods Description Vector2 FVector2 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Perpendicular Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up. Reflect Reflects a vector off the vector defined by a normal. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector2 FVector2 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector2 Converts a Vector3 to a Vector2. Vector3 Converts a Vector2 to a Vector3. Vector2 Converts(explicit) a FVector2 to a Vector2. FVector2 Converts(explicit) a FVector3 to a FVector2. FVector2 Converts(explicit) a Vector2 to a FVector2. FVector2 Converts(explicit) a Vector3 to a FVector2.","title":"Description"},{"location":"fixedmath/fvector3/","text":"Description \u00b6 Representation of 3D vectors and points. Static Properties Description Vector3 FVector3 back Shorthand for writing Vector3(0, 0, -1). down Shorthand for writing Vector3(0, -1, 0). forward Shorthand for writing Vector3(0, 0, 1). left Shorthand for writing Vector3(-1, 0, 0). negativeInfinity Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector3(1, 1, 1). positiveInfinity Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector3(1, 0, 0). up Shorthand for writing Vector3(0, 1, 0). zero Shorthand for writing Vector3(0, 0, 0). Properties Description Vector3 FVector3 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x, y, z component using [0], [1], [2] respectively. x X component of the vector. y Y component of the vector. z Z component of the vector. Constructors Description Vector3 FVector3 Vector3 Constructs a new vector with given x, y, z components. FVector3 Constructs a new vector with given x, y, z components. Public Methods Description Vector3 FVector3 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x, y, z components of an existing Vector3. ToString Returns a formatted string for this vector. Static Methods Description Vector3 FVector3 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Cross Cross Product of two vectors. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Normalize Makes this vector have a magnitude of 1. OrthoNormalize Makes vectors normalized and orthogonal to each other. Project Projects a vector onto another vector. ProjectOnPlane Projects a vector onto a plane defined by a normal orthogonal to the plane. Reflect Reflects a vector off the vector defined by a normal. RotateTowards Rotates a vector current towards target. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. Slerp Spherically interpolates between two vectors. SlerpUnclamped Spherically interpolates between two vectors. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector3 FVector3 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector3 Converts(explicit) a FVector3 to a Vector3. FVector3 Converts(explicit) a Vector3 to a FVector3. FVector3 Converts(explicit) a FVector2 to a FVector3.","title":"FVector3"},{"location":"fixedmath/fvector3/#description","text":"Representation of 3D vectors and points. Static Properties Description Vector3 FVector3 back Shorthand for writing Vector3(0, 0, -1). down Shorthand for writing Vector3(0, -1, 0). forward Shorthand for writing Vector3(0, 0, 1). left Shorthand for writing Vector3(-1, 0, 0). negativeInfinity Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector3(1, 1, 1). positiveInfinity Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector3(1, 0, 0). up Shorthand for writing Vector3(0, 1, 0). zero Shorthand for writing Vector3(0, 0, 0). Properties Description Vector3 FVector3 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x, y, z component using [0], [1], [2] respectively. x X component of the vector. y Y component of the vector. z Z component of the vector. Constructors Description Vector3 FVector3 Vector3 Constructs a new vector with given x, y, z components. FVector3 Constructs a new vector with given x, y, z components. Public Methods Description Vector3 FVector3 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x, y, z components of an existing Vector3. ToString Returns a formatted string for this vector. Static Methods Description Vector3 FVector3 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Cross Cross Product of two vectors. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Normalize Makes this vector have a magnitude of 1. OrthoNormalize Makes vectors normalized and orthogonal to each other. Project Projects a vector onto another vector. ProjectOnPlane Projects a vector onto a plane defined by a normal orthogonal to the plane. Reflect Reflects a vector off the vector defined by a normal. RotateTowards Rotates a vector current towards target. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. Slerp Spherically interpolates between two vectors. SlerpUnclamped Spherically interpolates between two vectors. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector3 FVector3 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector3 Converts(explicit) a FVector3 to a Vector3. FVector3 Converts(explicit) a Vector3 to a FVector3. FVector3 Converts(explicit) a FVector2 to a FVector3.","title":"Description"},{"location":"fixedmath/fvector4/","text":"","title":"Fvector4"},{"location":"fixedmath/reference/fmath-deg2rad/","text":"","title":"FMath.Deg2Rad"},{"location":"frameSync/importantClass/frameSyncAgent/","text":"FrameSyncAgent \u00b6 Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } } Events \u00b6 The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game. OnFrameSyncEngineCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. OnFrameSyncGameCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. OnCollectLocalPlayerInputs \u00b6 Called every frame to collect the inputs of the local player.","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#framesyncagent","text":"Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#events","text":"The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game.","title":"Events"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncenginecreated","text":"Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method.","title":"OnFrameSyncEngineCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncgamecreated","text":"Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method.","title":"OnFrameSyncGameCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#oncollectlocalplayerinputs","text":"Called every frame to collect the inputs of the local player.","title":"OnCollectLocalPlayerInputs"},{"location":"home/installation/","text":"Welcome to FrameSync \u00b6 Installation \u00b6 https://gitee.com/kcezorro/parallel-up.git https://gitee.com/kcezorro/frame-sync-up.git https://gitee.com/kcezorro/pathfinding-up.git https://gitee.com/kcezorro/frame-sync-debug-server.git","title":"Installation"},{"location":"home/installation/#welcome-to-framesync","text":"","title":"Welcome to FrameSync"},{"location":"home/installation/#installation","text":"https://gitee.com/kcezorro/parallel-up.git https://gitee.com/kcezorro/frame-sync-up.git https://gitee.com/kcezorro/pathfinding-up.git https://gitee.com/kcezorro/frame-sync-debug-server.git","title":"Installation"},{"location":"physics2d/parallelBoxCollider2D/","text":"Collider for 2D physics representing an axis-aligned rectangle.","title":"ParallelBoxCollider2D"},{"location":"physics2d/physics2D/","text":"Real-time rigidbody 2D physics based on Box2D. Classes \u00b6 Name Description ParallelBoxCollider2D Collider for 2D physics representing an axis-aligned rectangle. ParallelCapsuleCollider2D A capsule-shaped primitive collider. ParallelCircleCollider2D Collider for 2D physics representing an circle. ParallelCollider2D Parent class for collider types used with 2D gameplay. ParallelCollision2D Collision details returned by 2D physics callback functions. ParallelPhysics2D Global settings and helpers for 2D physics. ParallelPolygonCollider2D Collider for 2D physics representing an arbitrary polygon defined by its vertices. ParallelRigidbody2D Rigidbody physics component for 2D sprites. Structs \u00b6 Name Description Enumerations \u00b6","title":"Overview"},{"location":"physics2d/physics2D/#classes","text":"Name Description ParallelBoxCollider2D Collider for 2D physics representing an axis-aligned rectangle. ParallelCapsuleCollider2D A capsule-shaped primitive collider. ParallelCircleCollider2D Collider for 2D physics representing an circle. ParallelCollider2D Parent class for collider types used with 2D gameplay. ParallelCollision2D Collision details returned by 2D physics callback functions. ParallelPhysics2D Global settings and helpers for 2D physics. ParallelPolygonCollider2D Collider for 2D physics representing an arbitrary polygon defined by its vertices. ParallelRigidbody2D Rigidbody physics component for 2D sprites.","title":"Classes"},{"location":"physics2d/physics2D/#structs","text":"Name Description","title":"Structs"},{"location":"physics2d/physics2D/#enumerations","text":"","title":"Enumerations"},{"location":"tutorial/Race/overview/","text":"","title":"Overview"},{"location":"tutorial/pong/Rollback/","text":"Rollback \u00b6 You can adjust the ping value in the config.json file to simulate a bad internet connection. Set the ping to 150, it will inject a delay of 150ms to the packets sent between the debug server and the game clients. The RTT for the connections will be 300ms now. Play the game again, the input delay should be very noticeable. You'll add Rollback to your game to make it more responsive. IResotrable \u00b6 First, you will create a new class that implements IRestorable interface. A Rollback enabled game needs to rollback the game states to a confirmed frame from the server. The FrameSyncEngine will take care of the game states stored in the IFrameSyncData components. You need to provide the FrameSyncEngine with a IRestorable object to restore any states that are not stored in a IFrameSyncData component. C# public class MyRestorable : IRestorable { PSnapshot2D snapshot2D ; public int frameNumber { get ; } public MyRestorable ( int frameNumber ) { // 1 snapshot2D = Parallel2D . Snapshot (); this . frameNumber = frameNumber ; } public void Clear () { // 2 Parallel2D . DestroySnapshot ( snapshot2D ); } public void Restore () { // 3 Parallel2D . Restore ( snapshot2D ); } } In // 1 , you create a snapshot of the Parallel physics world. The created MyRestorable will be passed to the FrameSyncEngine. In // 2 , The FrameSyncEngine will call the Clear() method when it does not need to rollback to the frame for a IRestorable . You will destory the snapshot to free the memory in the Parallel physics world. In // 3 , The FrameSyncEngine will call the Restore() method when it wants to rollback to the frame for a IRestorable . You will use the snapshot to restore the physics state of the Parallel physics world. Next, add a public field rollback to the MyFrameSyncAgent script to enable/disable Rollback in the inspector. C# public bool rollback = false ; OnEngineWillExportEvent \u00b6 Make the following change to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); // 8 if ( rollback ) { engine . OnEngineWillExportEvent += FrameSyncEngineWillExport ; } } } In // 8 , we add our handler to the OnEngineWillExportEvent if rollback is enabled; C# IRestorable FrameSyncEngineWillExport ( int frameNumber ) { MyRestorable restorable = new MyRestorable ( frameNumber ); return restorable ; } You create an IRestorable in the event handler and returned it to the FrameSyncEngine. Enable Rollback \u00b6 Make the following change to the OnFrameSyncGameCreated method C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; // 8 game . clientSidePrediction = clientSidePrediction ; } } In // 8 , you enabled clientSidePrediction on your game. Play the game, the input delay should be reduced a lot now. Prediction Modifier \u00b6 You can use the Prediction Modifier to control the extrapolation for the other players. By default, the FrameSyncEngine just reuses the last received inputs to simulate other players for the prediction frames. Make the following change to the OnFrameSyncEngineCreated method. C# // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero , PredictionModifier ); In // 2 , you set the PredictionModifier method as the Prediction Modifier of the y input. C# Fix64 PredictionModifier ( Fix64 value ) { return value * Fix64 . half ; } The PredictionModifier method is very simply, the y input is decayed by 50%. The PredictionModifier method is called for every prediction frame, and the output of frame n will be used as the input for frame n+1 . So if the initial value of y is 1, the predicted values of y in the predicted frames will be 0.5 , 0.25 , 0.125 ...","title":"Rollback"},{"location":"tutorial/pong/Rollback/#rollback","text":"You can adjust the ping value in the config.json file to simulate a bad internet connection. Set the ping to 150, it will inject a delay of 150ms to the packets sent between the debug server and the game clients. The RTT for the connections will be 300ms now. Play the game again, the input delay should be very noticeable. You'll add Rollback to your game to make it more responsive.","title":"Rollback"},{"location":"tutorial/pong/Rollback/#iresotrable","text":"First, you will create a new class that implements IRestorable interface. A Rollback enabled game needs to rollback the game states to a confirmed frame from the server. The FrameSyncEngine will take care of the game states stored in the IFrameSyncData components. You need to provide the FrameSyncEngine with a IRestorable object to restore any states that are not stored in a IFrameSyncData component. C# public class MyRestorable : IRestorable { PSnapshot2D snapshot2D ; public int frameNumber { get ; } public MyRestorable ( int frameNumber ) { // 1 snapshot2D = Parallel2D . Snapshot (); this . frameNumber = frameNumber ; } public void Clear () { // 2 Parallel2D . DestroySnapshot ( snapshot2D ); } public void Restore () { // 3 Parallel2D . Restore ( snapshot2D ); } } In // 1 , you create a snapshot of the Parallel physics world. The created MyRestorable will be passed to the FrameSyncEngine. In // 2 , The FrameSyncEngine will call the Clear() method when it does not need to rollback to the frame for a IRestorable . You will destory the snapshot to free the memory in the Parallel physics world. In // 3 , The FrameSyncEngine will call the Restore() method when it wants to rollback to the frame for a IRestorable . You will use the snapshot to restore the physics state of the Parallel physics world. Next, add a public field rollback to the MyFrameSyncAgent script to enable/disable Rollback in the inspector. C# public bool rollback = false ;","title":"IResotrable"},{"location":"tutorial/pong/Rollback/#onenginewillexportevent","text":"Make the following change to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); // 8 if ( rollback ) { engine . OnEngineWillExportEvent += FrameSyncEngineWillExport ; } } } In // 8 , we add our handler to the OnEngineWillExportEvent if rollback is enabled; C# IRestorable FrameSyncEngineWillExport ( int frameNumber ) { MyRestorable restorable = new MyRestorable ( frameNumber ); return restorable ; } You create an IRestorable in the event handler and returned it to the FrameSyncEngine.","title":"OnEngineWillExportEvent"},{"location":"tutorial/pong/Rollback/#enable-rollback","text":"Make the following change to the OnFrameSyncGameCreated method C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; // 8 game . clientSidePrediction = clientSidePrediction ; } } In // 8 , you enabled clientSidePrediction on your game. Play the game, the input delay should be reduced a lot now.","title":"Enable Rollback"},{"location":"tutorial/pong/Rollback/#prediction-modifier","text":"You can use the Prediction Modifier to control the extrapolation for the other players. By default, the FrameSyncEngine just reuses the last received inputs to simulate other players for the prediction frames. Make the following change to the OnFrameSyncEngineCreated method. C# // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero , PredictionModifier ); In // 2 , you set the PredictionModifier method as the Prediction Modifier of the y input. C# Fix64 PredictionModifier ( Fix64 value ) { return value * Fix64 . half ; } The PredictionModifier method is very simply, the y input is decayed by 50%. The PredictionModifier method is called for every prediction frame, and the output of frame n will be used as the input for frame n+1 . So if the initial value of y is 1, the predicted values of y in the predicted frames will be 0.5 , 0.25 , 0.125 ...","title":"Prediction Modifier"},{"location":"tutorial/pong/ballManager/","text":"Ball Manager \u00b6 Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Kickoff \u00b6 The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball. Handle player ready input \u00b6 Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready. Boundary Check \u00b6 Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores. Reset the ball \u00b6 Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#ball-manager","text":"Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#kickoff","text":"The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball.","title":"Kickoff"},{"location":"tutorial/pong/ballManager/#handle-player-ready-input","text":"Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready.","title":"Handle player ready input"},{"location":"tutorial/pong/ballManager/#boundary-check","text":"Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores.","title":"Boundary Check"},{"location":"tutorial/pong/ballManager/#reset-the-ball","text":"Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Reset the ball"},{"location":"tutorial/pong/buildGame/","text":"Building the Game \u00b6 64-bit architecture \u00b6 FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit. Windowed mode \u00b6 Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 . Entering the debug PlayerUID \u00b6 Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#building-the-game","text":"","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#64-bit-architecture","text":"FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit.","title":"64-bit architecture"},{"location":"tutorial/pong/buildGame/#windowed-mode","text":"Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 .","title":"Windowed mode"},{"location":"tutorial/pong/buildGame/#entering-the-debug-playeruid","text":"Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Entering the debug PlayerUID"},{"location":"tutorial/pong/collectInput/","text":"Collecting Player Inputs \u00b6 OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/collectInput/#collecting-player-inputs","text":"OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/configEngine/","text":"Configuring the FrameSyncEngine \u00b6 OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring FrameSyncEngine"},{"location":"tutorial/pong/configEngine/#configuring-the-framesyncengine","text":"OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring the FrameSyncEngine"},{"location":"tutorial/pong/configGame/","text":"Configuring the FrameSyncGame \u00b6 OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring FrameSyncGame"},{"location":"tutorial/pong/configGame/#configuring-the-framesyncgame","text":"OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring the FrameSyncGame"},{"location":"tutorial/pong/connectToDebugServer/","text":"Connecting to the Debug Server \u00b6 Start scene \u00b6 You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build. Adding UI elements \u00b6 You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection MyGameServerConnection \u00b6 Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"Connecting to Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#connecting-to-the-debug-server","text":"","title":"Connecting to the Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#start-scene","text":"You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build.","title":"Start scene"},{"location":"tutorial/pong/connectToDebugServer/#adding-ui-elements","text":"You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection","title":"Adding UI elements"},{"location":"tutorial/pong/connectToDebugServer/#mygameserverconnection","text":"Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"MyGameServerConnection"},{"location":"tutorial/pong/createAgent/","text":"Creating FrameSyncAgent \u00b6 You will create an empty GameObject to house your customized FrameSyncAgent . MyFrameSyncAgent \u00b6 Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#creating-framesyncagent","text":"You will create an empty GameObject to house your customized FrameSyncAgent .","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#myframesyncagent","text":"Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"MyFrameSyncAgent"},{"location":"tutorial/pong/debugServer/","text":"Debug Server \u00b6 FrameSync comes with a debug server that helps you test and debug your game on your local machines. Install \u00b6 You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer Launch the server \u00b6 Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#debug-server","text":"FrameSync comes with a debug server that helps you test and debug your game on your local machines.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#install","text":"You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer","title":"Install"},{"location":"tutorial/pong/debugServer/#launch-the-server","text":"Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Launch the server"},{"location":"tutorial/pong/offline/","text":"Playing Offline \u00b6 Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/offline/#playing-offline","text":"Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/online/","text":"Online FrameSyncAgent \u00b6 You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field offline to the MyFrameSyncAgent script to control online/offline mode in the inspector C# public bool offline = false ; Updating the OnFrameSyncEngineCreated method \u00b6 Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } } Updating the OnFrameSyncGameCreated method \u00b6 Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing. Updating the OnCollectLocalPlayerInputs method \u00b6 Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#online-framesyncagent","text":"You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field offline to the MyFrameSyncAgent script to control online/offline mode in the inspector C# public bool offline = false ;","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#updating-the-onframesyncenginecreated-method","text":"Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } }","title":"Updating the OnFrameSyncEngineCreated method"},{"location":"tutorial/pong/online/#updating-the-onframesyncgamecreated-method","text":"Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing.","title":"Updating the OnFrameSyncGameCreated method"},{"location":"tutorial/pong/online/#updating-the-oncollectlocalplayerinputs-method","text":"Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Updating the OnCollectLocalPlayerInputs method"},{"location":"tutorial/pong/overview/","text":"","title":"Overview"},{"location":"tutorial/pong/paddleMovement/","text":"Paddle Movement \u00b6 Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } } FrameSyncUpdate \u00b6 Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#paddle-movement","text":"Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } }","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#framesyncupdate","text":"Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"FrameSyncUpdate"},{"location":"tutorial/pong/paddleOwner/","text":"Paddle Owner \u00b6 Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } FrameSyncDataInitialize \u00b6 The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#paddle-owner","text":"Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#framesyncdatainitialize","text":"The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"FrameSyncDataInitialize"},{"location":"tutorial/pong/paddlePosition/","text":"Paddle Position Data \u00b6 Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Importing \u00b6 Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value. Exporting \u00b6 Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#paddle-position-data","text":"Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#importing","text":"Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value.","title":"Importing"},{"location":"tutorial/pong/paddlePosition/#exporting","text":"Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Exporting"},{"location":"tutorial/pong/parallel2d/","text":"Physics 2D \u00b6 FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller . Rigidbodies \u00b6 Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move Creating the ball \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject. Creating the paddles \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) . Creating the walls \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) . Setting up the camera \u00b6 Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 . Final touch \u00b6 You can change the color of the sprite to your liking. The scene should look like.","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#physics-2d","text":"FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller .","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#rigidbodies","text":"Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move","title":"Rigidbodies"},{"location":"tutorial/pong/parallel2d/#creating-the-ball","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject.","title":"Creating the ball"},{"location":"tutorial/pong/parallel2d/#creating-the-paddles","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) .","title":"Creating the paddles"},{"location":"tutorial/pong/parallel2d/#creating-the-walls","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) .","title":"Creating the walls"},{"location":"tutorial/pong/parallel2d/#setting-up-the-camera","text":"Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 .","title":"Setting up the camera"},{"location":"tutorial/pong/parallel2d/#final-touch","text":"You can change the color of the sprite to your liking. The scene should look like.","title":"Final touch"},{"location":"tutorial/pong/staticFrameSyncBehaviour/","text":"StaticFrameSyncBehaviour \u00b6 FrameSync managed updates \u00b6 StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method. FrameSync managed data \u00b6 When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data. Which GameObject should have a StaticFrameSyncBehaviour? \u00b6 You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them. Adding the StaticFrameSyncBehaviour componennt \u00b6 Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour . Assign the StaticFrameSyncBehaviourID \u00b6 You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#staticframesyncbehaviour","text":"","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-updates","text":"StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method.","title":"FrameSync managed updates"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-data","text":"When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data.","title":"FrameSync managed data"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#which-gameobject-should-have-a-staticframesyncbehaviour","text":"You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them.","title":"Which GameObject should have a StaticFrameSyncBehaviour?"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#adding-the-staticframesyncbehaviour-componennt","text":"Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour .","title":"Adding the StaticFrameSyncBehaviour componennt"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#assign-the-staticframesyncbehaviourid","text":"You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"Assign the StaticFrameSyncBehaviourID"},{"location":"tutorial/pong/viewFrame/","text":"Frame Information \u00b6 The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods. Export frame info for PaddlePositionData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); } Export frame info for PaddleOwnerData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); } Export frame info for BallManager \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); } Reset the debug server \u00b6 You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#frame-information","text":"The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddlepositiondata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); }","title":"Export frame info for PaddlePositionData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddleownerdata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); }","title":"Export frame info for PaddleOwnerData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-ballmanager","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); }","title":"Export frame info for BallManager"},{"location":"tutorial/pong/viewFrame/#reset-the-debug-server","text":"You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Reset the debug server"}]}