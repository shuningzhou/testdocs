{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Overview"},{"location":"fixedmath/ffloat/","text":"","title":"Ffloat"},{"location":"fixedmath/fixedmath/","text":"A C# fixed point math library for vector and matrix computation. This library is designed to match the Unity Mathf class as well as the Unity vector and matrix types. FixedMath Unity Math FMath Mathf FFloat float FVector2 Vector2 FVector3 Vector3 FVector4 Vector4 FMatrix4x4 Matrix4x4 FQuaternion Quaternion","title":"Overview"},{"location":"fixedmath/fmath/","text":"Description \u00b6 A collection of common math functions. Static Properties Description Mathf FMath Deg2Rad Degrees-to-radians conversion constant (Read Only). Epsilon A tiny floating point value (Read Only). 1 Infinity A representation of positive infinity (Read Only). 2 NegativeInfinity A representation of negative infinity (Read Only). 3 PI The well-known 3.14159265358979... value (Read Only). Rad2Deg Radians-to-degrees conversion constant (Read Only). Static Methods Description Mathf FMath Abs Returns the absolute value of f. Acos Returns the arc-cosine of f - the angle in radians whose cosine is f. Approximately Compares two floating point values and returns true if they are similar. Asin Returns the arc-sine of f - the angle in radians whose sine is f. Atan Returns the arc-tangent of f - the angle in radians whose tangent is f. Atan2 Returns the angle in radians whose Tan is y/x. Ceil Returns the smallest integer greater to or equal to f. CeilToInt Returns the smallest integer greater to or equal to f. Clamp Clamps the given value between the given minimum float and maximum float values. Returns the given value if it is within the min and max range. Clamp01 Clamps value between 0 and 1 and returns value. ClosestPowerOfTwo Returns the closest power of two value. CorrelatedColorTemperatureToRGB Convert a color temperature in Kelvin to RGB color. Cos Returns the cosine of angle f. DeltaAngle Calculates the shortest difference between two given angles given in degrees. Exp Returns e raised to the specified power. FloatToHalf Encode a floating point value into a 16-bit representation. Floor Returns the largest integer smaller than or equal to f. FloorToInt Returns the largest integer smaller to or equal to f. GammaToLinearSpace Converts the given value from gamma (sRGB) to linear color space. HalfToFloat Convert a half precision float to a 32-bit floating point value. InverseLerp Calculates the linear parameter t that produces the interpolant value within the range [a, b]. IsPowerOfTwo Returns true if the value is power of two. Lerp Linearly interpolates between a and b by t. LerpAngle Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees. LerpUnclamped Linearly interpolates between a and b by t with no limit to t. LinearToGammaSpace Converts the given value from linear to gamma (sRGB) color space. Log Returns the logarithm of a specified number in a specified base. Log10 Returns the base 10 logarithm of a specified number. Max Returns largest of two or more values. Min Returns the smallest of two or more values. MoveTowards Moves a value current towards target. MoveTowardsAngle Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees. NextPowerOfTwo Returns the next power of two that is equal to, or greater than, the argument. PerlinNoise Generate 2D Perlin noise. PingPong PingPong returns a value that will increment and decrement between the value 0 and length. Pow Returns f raised to power p. Repeat Loops the value t, so that it is never larger than length and never smaller than 0. Round Returns f rounded to the nearest integer. RoundToInt Returns f rounded to the nearest integer. Sign Returns the sign of f. Sin Returns the sine of angle f. SmoothDamp Gradually changes a value towards a desired goal over time. SmoothDampAngle Gradually changes an angle given in degrees towards a desired goal angle over time. SmoothStep Interpolates between min and max with smoothing at the limits. Sqrt Returns square root of f. Tan Returns the tangent of angle f in radians. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9","title":"FMath"},{"location":"fixedmath/fmath/#description","text":"A collection of common math functions. Static Properties Description Mathf FMath Deg2Rad Degrees-to-radians conversion constant (Read Only). Epsilon A tiny floating point value (Read Only). 1 Infinity A representation of positive infinity (Read Only). 2 NegativeInfinity A representation of negative infinity (Read Only). 3 PI The well-known 3.14159265358979... value (Read Only). Rad2Deg Radians-to-degrees conversion constant (Read Only). Static Methods Description Mathf FMath Abs Returns the absolute value of f. Acos Returns the arc-cosine of f - the angle in radians whose cosine is f. Approximately Compares two floating point values and returns true if they are similar. Asin Returns the arc-sine of f - the angle in radians whose sine is f. Atan Returns the arc-tangent of f - the angle in radians whose tangent is f. Atan2 Returns the angle in radians whose Tan is y/x. Ceil Returns the smallest integer greater to or equal to f. CeilToInt Returns the smallest integer greater to or equal to f. Clamp Clamps the given value between the given minimum float and maximum float values. Returns the given value if it is within the min and max range. Clamp01 Clamps value between 0 and 1 and returns value. ClosestPowerOfTwo Returns the closest power of two value. CorrelatedColorTemperatureToRGB Convert a color temperature in Kelvin to RGB color. Cos Returns the cosine of angle f. DeltaAngle Calculates the shortest difference between two given angles given in degrees. Exp Returns e raised to the specified power. FloatToHalf Encode a floating point value into a 16-bit representation. Floor Returns the largest integer smaller than or equal to f. FloorToInt Returns the largest integer smaller to or equal to f. GammaToLinearSpace Converts the given value from gamma (sRGB) to linear color space. HalfToFloat Convert a half precision float to a 32-bit floating point value. InverseLerp Calculates the linear parameter t that produces the interpolant value within the range [a, b]. IsPowerOfTwo Returns true if the value is power of two. Lerp Linearly interpolates between a and b by t. LerpAngle Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees. LerpUnclamped Linearly interpolates between a and b by t with no limit to t. LinearToGammaSpace Converts the given value from linear to gamma (sRGB) color space. Log Returns the logarithm of a specified number in a specified base. Log10 Returns the base 10 logarithm of a specified number. Max Returns largest of two or more values. Min Returns the smallest of two or more values. MoveTowards Moves a value current towards target. MoveTowardsAngle Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees. NextPowerOfTwo Returns the next power of two that is equal to, or greater than, the argument. PerlinNoise Generate 2D Perlin noise. PingPong PingPong returns a value that will increment and decrement between the value 0 and length. Pow Returns f raised to power p. Repeat Loops the value t, so that it is never larger than length and never smaller than 0. Round Returns f rounded to the nearest integer. RoundToInt Returns f rounded to the nearest integer. Sign Returns the sign of f. Sin Returns the sine of angle f. SmoothDamp Gradually changes a value towards a desired goal over time. SmoothDampAngle Gradually changes an angle given in degrees towards a desired goal angle over time. SmoothStep Interpolates between min and max with smoothing at the limits. Sqrt Returns square root of f. Tan Returns the tangent of angle f in radians. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9","title":"Description"},{"location":"fixedmath/fmatrix4x4/","text":"Description \u00b6 A standard 4x4 transformation matrix. Static Properties Description Matrix4x4 FMatrix4x4 identity Returns the identity matrix (Read Only). zero Returns a matrix with all elements set to zero (Read Only). Properties Description Matrix4x4 FMatrix4x4 decomposeProjection This property takes a projection matrix and returns the six plane coordinates that define a projection frustum. determinant The determinant of the matrix. (Read Only) inverse The inverse of this matrix. (Read Only) isIdentity Checks whether this is an identity matrix. (Read Only) lossyScale Attempts to get a scale value from the matrix. (Read Only) rotation Attempts to get a rotation quaternion from this matrix. this[int,int] Access element at [row, column]. transpose Returns the transpose of this matrix (Read Only). Public Methods Description Matrix4x4 FMatrix4x4 GetColumn Get a column of the matrix. GetRow Returns a row of the matrix. MultiplyPoint Transforms a position by this matrix (generic). MultiplyPoint3x4 Transforms a position by this matrix (fast). MultiplyVector Transforms a direction by this matrix. SetColumn Sets a column of the matrix. SetRow Sets a row of the matrix. SetTRS Sets this matrix to a translation, rotation and scaling matrix. ToString Returns a formatted string for this matrix. TransformPlane Returns a plane that is transformed in space. ValidTRS Checks if this matrix is a valid transform matrix. Static Methods Description Matrix4x4 FMatrix4x4 Frustum This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in. Inverse3DAffine Computes the inverse of a 3D affine matrix. LookAt Create a \"look at\" matrix. Ortho Create an orthogonal projection matrix. Perspective Create a perspective projection matrix. Rotate Creates a rotation matrix. Scale Creates a scaling matrix. Translate Creates a translation matrix. TRS Creates a translation, rotation and scaling matrix. Operators Description Matrix4x4 FMatrix4x4 operator * Multiplies two matrices.","title":"FMatrix4x4"},{"location":"fixedmath/fmatrix4x4/#description","text":"A standard 4x4 transformation matrix. Static Properties Description Matrix4x4 FMatrix4x4 identity Returns the identity matrix (Read Only). zero Returns a matrix with all elements set to zero (Read Only). Properties Description Matrix4x4 FMatrix4x4 decomposeProjection This property takes a projection matrix and returns the six plane coordinates that define a projection frustum. determinant The determinant of the matrix. (Read Only) inverse The inverse of this matrix. (Read Only) isIdentity Checks whether this is an identity matrix. (Read Only) lossyScale Attempts to get a scale value from the matrix. (Read Only) rotation Attempts to get a rotation quaternion from this matrix. this[int,int] Access element at [row, column]. transpose Returns the transpose of this matrix (Read Only). Public Methods Description Matrix4x4 FMatrix4x4 GetColumn Get a column of the matrix. GetRow Returns a row of the matrix. MultiplyPoint Transforms a position by this matrix (generic). MultiplyPoint3x4 Transforms a position by this matrix (fast). MultiplyVector Transforms a direction by this matrix. SetColumn Sets a column of the matrix. SetRow Sets a row of the matrix. SetTRS Sets this matrix to a translation, rotation and scaling matrix. ToString Returns a formatted string for this matrix. TransformPlane Returns a plane that is transformed in space. ValidTRS Checks if this matrix is a valid transform matrix. Static Methods Description Matrix4x4 FMatrix4x4 Frustum This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in. Inverse3DAffine Computes the inverse of a 3D affine matrix. LookAt Create a \"look at\" matrix. Ortho Create an orthogonal projection matrix. Perspective Create a perspective projection matrix. Rotate Creates a rotation matrix. Scale Creates a scaling matrix. Translate Creates a translation matrix. TRS Creates a translation, rotation and scaling matrix. Operators Description Matrix4x4 FMatrix4x4 operator * Multiplies two matrices.","title":"Description"},{"location":"fixedmath/fquaternion/","text":"Description \u00b6 Quaternions are used to represent rotations. Static Properties Description Quaternion FQuaternion identity The identity rotation (Read Only). Properties Description Quaternion FQuaternion eulerAngles Returns or sets the euler angle representation of the rotation. normalized Returns this quaternion with a magnitude of 1 (Read Only). this[int] Access the x, y, z, w components using [0], [1], [2], [3] respectively. w W component of the Quaternion. Do not directly modify quaternions. x X component of the Quaternion. Don't modify this directly unless you know quaternions inside out. y Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out. z Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out. Constructors Description Quaternion FQuaternion Quaternion Constructs new Quaternion with given x,y,z,w components. FQuaternion Constructs new Quaternion with given x,y,z,w components. Public Methods Description Quaternion FMaFQuaternionth Set Set x, y, z and w components of an existing Quaternion. SetFromToRotation Creates a rotation which rotates from fromDirection to toDirection. SetLookRotation Creates a rotation with the specified forward and upwards directions. ToAngleAxis Converts a rotation to angle-axis representation (angles in degrees). ToString Returns a formatted string of the Quaternion. Static Methods Description Quaternion FQuaternion Angle Returns the angle in degrees between two rotations a and b. AngleAxis Creates a rotation which rotates angle degrees around axis. Dot The dot product between two rotations. Euler Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order. FromToRotation Creates a rotation which rotates from fromDirection to toDirection. Inverse Returns the Inverse of rotation. Lerp Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1]. LerpUnclamped Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped. LookRotation Creates a rotation with the specified forward and upwards directions. Normalize Converts this quaternion to one with the same orientation but with a magnitude of 1. RotateTowards Rotates a rotation from towards to. Slerp Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1]. SlerpUnclamped Spherically interpolates between a and b by t. The parameter t is not clamped. Operators Description Quaternion FQuaternion operator * Combines rotations lhs and rhs. operator == Are two quaternions equal to each other?","title":"FQuaternion"},{"location":"fixedmath/fquaternion/#description","text":"Quaternions are used to represent rotations. Static Properties Description Quaternion FQuaternion identity The identity rotation (Read Only). Properties Description Quaternion FQuaternion eulerAngles Returns or sets the euler angle representation of the rotation. normalized Returns this quaternion with a magnitude of 1 (Read Only). this[int] Access the x, y, z, w components using [0], [1], [2], [3] respectively. w W component of the Quaternion. Do not directly modify quaternions. x X component of the Quaternion. Don't modify this directly unless you know quaternions inside out. y Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out. z Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out. Constructors Description Quaternion FQuaternion Quaternion Constructs new Quaternion with given x,y,z,w components. FQuaternion Constructs new Quaternion with given x,y,z,w components. Public Methods Description Quaternion FMaFQuaternionth Set Set x, y, z and w components of an existing Quaternion. SetFromToRotation Creates a rotation which rotates from fromDirection to toDirection. SetLookRotation Creates a rotation with the specified forward and upwards directions. ToAngleAxis Converts a rotation to angle-axis representation (angles in degrees). ToString Returns a formatted string of the Quaternion. Static Methods Description Quaternion FQuaternion Angle Returns the angle in degrees between two rotations a and b. AngleAxis Creates a rotation which rotates angle degrees around axis. Dot The dot product between two rotations. Euler Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order. FromToRotation Creates a rotation which rotates from fromDirection to toDirection. Inverse Returns the Inverse of rotation. Lerp Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1]. LerpUnclamped Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped. LookRotation Creates a rotation with the specified forward and upwards directions. Normalize Converts this quaternion to one with the same orientation but with a magnitude of 1. RotateTowards Rotates a rotation from towards to. Slerp Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1]. SlerpUnclamped Spherically interpolates between a and b by t. The parameter t is not clamped. Operators Description Quaternion FQuaternion operator * Combines rotations lhs and rhs. operator == Are two quaternions equal to each other?","title":"Description"},{"location":"fixedmath/fvector2/","text":"Description \u00b6 Representation of 2D vectors and points. Static Properties Description Vector2 FVector2 down Shorthand for writing Vector2(0, -1). left Shorthand for writing Vector2(-1, 0). negativeInfinity Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector2(1, 1). positiveInfinity Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector2(1, 0). up Shorthand for writing Vector2(0, 1). zero Shorthand for writing Vector2(0, 0). Properties Description Vector2 FVector2 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x or y component using [0] or [1] respectively. x X component of the vector. y Y component of the vector. Constructors Description Vector2 FVector2 Vector2 Constructs a new vector with given x, y components. FVector2 Constructs a new vector with given x, y components. Public Methods Description Vector2 FVector2 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x and y components of an existing Vector2. ToString Returns a formatted string for this vector. Static Methods Description Vector2 FVector2 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Perpendicular Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up. Reflect Reflects a vector off the vector defined by a normal. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector2 FVector2 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector2 Converts a Vector3 to a Vector2. Vector3 Converts a Vector2 to a Vector3. Vector2 Converts(explicit) a FVector2 to a Vector2. FVector2 Converts(explicit) a FVector3 to a FVector2. FVector2 Converts(explicit) a Vector2 to a FVector2. FVector2 Converts(explicit) a Vector3 to a FVector2.","title":"FVector2"},{"location":"fixedmath/fvector2/#description","text":"Representation of 2D vectors and points. Static Properties Description Vector2 FVector2 down Shorthand for writing Vector2(0, -1). left Shorthand for writing Vector2(-1, 0). negativeInfinity Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector2(1, 1). positiveInfinity Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector2(1, 0). up Shorthand for writing Vector2(0, 1). zero Shorthand for writing Vector2(0, 0). Properties Description Vector2 FVector2 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x or y component using [0] or [1] respectively. x X component of the vector. y Y component of the vector. Constructors Description Vector2 FVector2 Vector2 Constructs a new vector with given x, y components. FVector2 Constructs a new vector with given x, y components. Public Methods Description Vector2 FVector2 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x and y components of an existing Vector2. ToString Returns a formatted string for this vector. Static Methods Description Vector2 FVector2 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Perpendicular Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up. Reflect Reflects a vector off the vector defined by a normal. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector2 FVector2 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector2 Converts a Vector3 to a Vector2. Vector3 Converts a Vector2 to a Vector3. Vector2 Converts(explicit) a FVector2 to a Vector2. FVector2 Converts(explicit) a FVector3 to a FVector2. FVector2 Converts(explicit) a Vector2 to a FVector2. FVector2 Converts(explicit) a Vector3 to a FVector2.","title":"Description"},{"location":"fixedmath/fvector3/","text":"Description \u00b6 Representation of 3D vectors and points. Static Properties Description Vector3 FVector3 back Shorthand for writing Vector3(0, 0, -1). down Shorthand for writing Vector3(0, -1, 0). forward Shorthand for writing Vector3(0, 0, 1). left Shorthand for writing Vector3(-1, 0, 0). negativeInfinity Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector3(1, 1, 1). positiveInfinity Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector3(1, 0, 0). up Shorthand for writing Vector3(0, 1, 0). zero Shorthand for writing Vector3(0, 0, 0). Properties Description Vector3 FVector3 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x, y, z component using [0], [1], [2] respectively. x X component of the vector. y Y component of the vector. z Z component of the vector. Constructors Description Vector3 FVector3 Vector3 Constructs a new vector with given x, y, z components. FVector3 Constructs a new vector with given x, y, z components. Public Methods Description Vector3 FVector3 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x, y, z components of an existing Vector3. ToString Returns a formatted string for this vector. Static Methods Description Vector3 FVector3 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Cross Cross Product of two vectors. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Normalize Makes this vector have a magnitude of 1. OrthoNormalize Makes vectors normalized and orthogonal to each other. Project Projects a vector onto another vector. ProjectOnPlane Projects a vector onto a plane defined by a normal orthogonal to the plane. Reflect Reflects a vector off the vector defined by a normal. RotateTowards Rotates a vector current towards target. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. Slerp Spherically interpolates between two vectors. SlerpUnclamped Spherically interpolates between two vectors. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector3 FVector3 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector3 Converts(explicit) a FVector3 to a Vector3. FVector3 Converts(explicit) a Vector3 to a FVector3. FVector3 Converts(explicit) a FVector2 to a FVector3.","title":"FVector3"},{"location":"fixedmath/fvector3/#description","text":"Representation of 3D vectors and points. Static Properties Description Vector3 FVector3 back Shorthand for writing Vector3(0, 0, -1). down Shorthand for writing Vector3(0, -1, 0). forward Shorthand for writing Vector3(0, 0, 1). left Shorthand for writing Vector3(-1, 0, 0). negativeInfinity Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity). one Shorthand for writing Vector3(1, 1, 1). positiveInfinity Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity). right Shorthand for writing Vector3(1, 0, 0). up Shorthand for writing Vector3(0, 1, 0). zero Shorthand for writing Vector3(0, 0, 0). Properties Description Vector3 FVector3 magnitude Returns the length of this vector (Read Only). normalized Returns this vector with a magnitude of 1 (Read Only). sqrMagnitude Returns the squared length of this vector (Read Only). this[int] Access the x, y, z component using [0], [1], [2] respectively. x X component of the vector. y Y component of the vector. z Z component of the vector. Constructors Description Vector3 FVector3 Vector3 Constructs a new vector with given x, y, z components. FVector3 Constructs a new vector with given x, y, z components. Public Methods Description Vector3 FVector3 Equals Returns true if the given vector is exactly equal to this vector. Normalize Makes this vector have a magnitude of 1. Set Set x, y, z components of an existing Vector3. ToString Returns a formatted string for this vector. Static Methods Description Vector3 FVector3 Angle Returns the unsigned angle in degrees between from and to. ClampMagnitude Returns a copy of vector with its magnitude clamped to maxLength. Cross Cross Product of two vectors. Distance Returns the distance between a and b. Dot Dot Product of two vectors. Lerp Linearly interpolates between vectors a and b by t. LerpUnclamped Linearly interpolates between vectors a and b by t. Max Returns a vector that is made from the largest components of two vectors. Min Returns a vector that is made from the smallest components of two vectors. MoveTowards Moves a point current towards target. Normalize Makes this vector have a magnitude of 1. OrthoNormalize Makes vectors normalized and orthogonal to each other. Project Projects a vector onto another vector. ProjectOnPlane Projects a vector onto a plane defined by a normal orthogonal to the plane. Reflect Reflects a vector off the vector defined by a normal. RotateTowards Rotates a vector current towards target. Scale Multiplies two vectors component-wise. SignedAngle Returns the signed angle in degrees between from and to. Slerp Spherically interpolates between two vectors. SlerpUnclamped Spherically interpolates between two vectors. SmoothDamp Gradually changes a vector towards a desired goal over time. Operators Description Vector3 FVector3 operator - Subtracts one vector from another. operator * Multiplies a vector by a number. operator / Divides a vector by a number. operator + Adds two vectors. operator == Returns true if two vectors are approximately equal. Vector3 Converts(explicit) a FVector3 to a Vector3. FVector3 Converts(explicit) a Vector3 to a FVector3. FVector3 Converts(explicit) a FVector2 to a FVector3.","title":"Description"},{"location":"fixedmath/fvector4/","text":"","title":"Fvector4"},{"location":"fixedmath/reference/fmath-deg2rad/","text":"FMath.Deg2Rad \u00b6 public static float Deg2Rad; Description \u00b6 Degrees-to-radians conversion constant (Read Only). This is equal to (PI * 2) / 360. C# using UnityEngine ; using SocketWeaver.FixedMath ; public class ExampleClass : MonoBehaviour { public FFloat deg = FFloat . FromDivision ( 30 , 1 ); void Start () { FFloat rad = deg * FMath . Deg2Rad ; Debug . Log ( deg + \" degrees are equal to \" + rad + \" radians.\" ); } }","title":"FMath.Deg2Rad"},{"location":"fixedmath/reference/fmath-deg2rad/#fmathdeg2rad","text":"public static float Deg2Rad;","title":"FMath.Deg2Rad"},{"location":"fixedmath/reference/fmath-deg2rad/#description","text":"Degrees-to-radians conversion constant (Read Only). This is equal to (PI * 2) / 360. C# using UnityEngine ; using SocketWeaver.FixedMath ; public class ExampleClass : MonoBehaviour { public FFloat deg = FFloat . FromDivision ( 30 , 1 ); void Start () { FFloat rad = deg * FMath . Deg2Rad ; Debug . Log ( deg + \" degrees are equal to \" + rad + \" radians.\" ); } }","title":"Description"},{"location":"frameSync/InputSettings/","text":"Input Settings \u00b6 InputSettings declare the inputs that your game uses. The FrameSyncEngine uses InputSettings to create player Input frames Creating an InputSettings asset \u00b6 To create an InputSettings for your game, right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings . Editing Inputs \u00b6 To add a new input, select the + icon of the Inputs list. To remove an input, select the input and select the - icon of the Inputs list. The name of an input must be unique. You cannot have two or more inputs with the same name. FrameSync supports inputs of type: Trigger , Bool , Int , float , Vector2 , and Vector3 . Make sure to optimize the input data size by adjusting the input's min, max, and resolution. Saving and Code Generation \u00b6 Caution Make sure that you entered the correct namespace of your project. Extension methods will be generated under the provided namespace to help you get and set the inputs. To save your changes to the InputSettings, click on the Save button at the bottom of the Inspector. Generated Extension Methods \u00b6 The generated extension methods are located at Assets->SocketWeaver->framesync_generated_input->{Your namespace} C# // Generated file, do not modify using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public static class gen_FrameSyncInputSettings { public static void SetInputY ( this FrameSyncPlayer player , FFloat value ) { player . SetFloat ( 0 , value ); } public static FFloat GetInputY ( this FrameSyncPlayer player ) { return player . GetFloat ( 0 ); } } }","title":"Input Settings"},{"location":"frameSync/InputSettings/#input-settings","text":"InputSettings declare the inputs that your game uses. The FrameSyncEngine uses InputSettings to create player Input frames","title":"Input Settings"},{"location":"frameSync/InputSettings/#creating-an-inputsettings-asset","text":"To create an InputSettings for your game, right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings .","title":"Creating an InputSettings asset"},{"location":"frameSync/InputSettings/#editing-inputs","text":"To add a new input, select the + icon of the Inputs list. To remove an input, select the input and select the - icon of the Inputs list. The name of an input must be unique. You cannot have two or more inputs with the same name. FrameSync supports inputs of type: Trigger , Bool , Int , float , Vector2 , and Vector3 . Make sure to optimize the input data size by adjusting the input's min, max, and resolution.","title":"Editing Inputs"},{"location":"frameSync/InputSettings/#saving-and-code-generation","text":"Caution Make sure that you entered the correct namespace of your project. Extension methods will be generated under the provided namespace to help you get and set the inputs. To save your changes to the InputSettings, click on the Save button at the bottom of the Inspector.","title":"Saving and Code Generation"},{"location":"frameSync/InputSettings/#generated-extension-methods","text":"The generated extension methods are located at Assets->SocketWeaver->framesync_generated_input->{Your namespace} C# // Generated file, do not modify using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public static class gen_FrameSyncInputSettings { public static void SetInputY ( this FrameSyncPlayer player , FFloat value ) { player . SetFloat ( 0 , value ); } public static FFloat GetInputY ( this FrameSyncPlayer player ) { return player . GetFloat ( 0 ); } } }","title":"Generated Extension Methods"},{"location":"frameSync/PrefabRegistry/","text":"Prefab Registry \u00b6 Prefab Registry declares the prefabs that your game instantiates and destroys at runtime. The FrameSyncEninge uses the Prefab Registry to identify a prefab at runtime. Creating a PrefabRegistry asset \u00b6 To create a Prefab Registry for your game, right click in the project browser, and select Create->SocketWeaver->FrameSync->Prefab Registry . Adding and Removing Prefabs \u00b6 To add a new prefab, select the + icon of the Prefab list. You can also select multiple prefabs in the project browser and drop them into the Prefab list. To remove a prefab, select prefab in the list and select the - icon of the Prefab list.","title":"Prefab Registry"},{"location":"frameSync/PrefabRegistry/#prefab-registry","text":"Prefab Registry declares the prefabs that your game instantiates and destroys at runtime. The FrameSyncEninge uses the Prefab Registry to identify a prefab at runtime.","title":"Prefab Registry"},{"location":"frameSync/PrefabRegistry/#creating-a-prefabregistry-asset","text":"To create a Prefab Registry for your game, right click in the project browser, and select Create->SocketWeaver->FrameSync->Prefab Registry .","title":"Creating a PrefabRegistry asset"},{"location":"frameSync/PrefabRegistry/#adding-and-removing-prefabs","text":"To add a new prefab, select the + icon of the Prefab list. You can also select multiple prefabs in the project browser and drop them into the Prefab list. To remove a prefab, select prefab in the list and select the - icon of the Prefab list.","title":"Adding and Removing Prefabs"},{"location":"frameSync/deterministic/","text":"Deterministic \u00b6 You game logic must be deterministic to the bit-level. The FrameSync library only sends and manages players inputs. This means that given the same input, your game logic should produce the exact same game states on all supported platforms. Challenages to Achieve Cross-platform Deterministic \u00b6 Floating point : nearly impossible to have deterministic floating point calculation on different machines. Physics Engine : Most physics engines use floating point so they are not deterministic on different machines. Other Tools : Similar to the physics engines, probably all the tools that you currently use (Navigation, Animatior, StateMachine, BehaviourTree, etc...) are not deterministic on different machines. FixedMath \u00b6 FrameSync provides a fixed point math library FixedMath which is cross-platform deterministic. FixedMath Unity FMath Mathf FFloat float FVector2 Vector2 FVector3 Vector3 FVector4 Vector4 FMatrix4x4 Matrix4x4 FQuaternion Quaternion FTransform Transform You can use it to replace float , Vector2 , Vector3 , Quaternion , Matrix4x4 , Mathf , and the Transform component to implment your game logic. FPhyscis \u00b6 Cross-platform deterministic 2D and 3D physics engines which run on the FixedMath library. They are designed to be used with the FrameSync library. Deterministic Execution Order \u00b6 You can implement your game logic in the IFrameSync interfaces as their update order is guarenteed deterministic.","title":"Deterministic"},{"location":"frameSync/deterministic/#deterministic","text":"You game logic must be deterministic to the bit-level. The FrameSync library only sends and manages players inputs. This means that given the same input, your game logic should produce the exact same game states on all supported platforms.","title":"Deterministic"},{"location":"frameSync/deterministic/#challenages-to-achieve-cross-platform-deterministic","text":"Floating point : nearly impossible to have deterministic floating point calculation on different machines. Physics Engine : Most physics engines use floating point so they are not deterministic on different machines. Other Tools : Similar to the physics engines, probably all the tools that you currently use (Navigation, Animatior, StateMachine, BehaviourTree, etc...) are not deterministic on different machines.","title":"Challenages to Achieve Cross-platform Deterministic"},{"location":"frameSync/deterministic/#fixedmath","text":"FrameSync provides a fixed point math library FixedMath which is cross-platform deterministic. FixedMath Unity FMath Mathf FFloat float FVector2 Vector2 FVector3 Vector3 FVector4 Vector4 FMatrix4x4 Matrix4x4 FQuaternion Quaternion FTransform Transform You can use it to replace float , Vector2 , Vector3 , Quaternion , Matrix4x4 , Mathf , and the Transform component to implment your game logic.","title":"FixedMath"},{"location":"frameSync/deterministic/#fphyscis","text":"Cross-platform deterministic 2D and 3D physics engines which run on the FixedMath library. They are designed to be used with the FrameSync library.","title":"FPhyscis"},{"location":"frameSync/deterministic/#deterministic-execution-order","text":"You can implement your game logic in the IFrameSync interfaces as their update order is guarenteed deterministic.","title":"Deterministic Execution Order"},{"location":"frameSync/frameSyncBehaviours/","text":"FrameSyncBehaviours \u00b6 The FrameSyncBehaviour class derives from MonoBehaviour . It acts as the unique identifier of a GameObject. All of the networked GameObjects should have a FrameSyncBehaviour component. Info To implement game logic and to store game states, implement IFrameSyncStart , IFrameSyncPlayerUpdate , IFrameSyncComputerUpdate , and IFrameSyncDataContainer interfaces in your MonoBehaviour component scripts and attach them to your networked GameObjects. StaticFrameSyncBehaviours \u00b6 Designed for GameObjects that are not dynamically instantiated or destroyed. If a GameObject is instantiated or destroyed at runtime, DynamicFrameSyncBehaviour should be used. DynamicFrameSyncBehaviours \u00b6 Designed for GameObjects that are dynamically instantiated or destroyed. Info DynamicFrameSyncBehaviour components will be automatically added to the GameObjects created at runtime. You don't need to add it to your prefabs. Properties \u00b6 Name Function Frame Sync Owner The owner of the FrameSyncBehaviour . For StaticFrameSyncBehaviour , its owner should be set in the editor. For DynamicFrameSyncBehaviour , it's owner is set on creation. Large Data Container By default, a FrameSyncBehaviour can contain up to 256 bytes of data. If Large Data Container is enabled, the limit is increased to 4096 bytes. id The UInt32 unique identifier of the GameObject. The property is for debug purpose and is readonly.","title":"FrameSyncBehaviours"},{"location":"frameSync/frameSyncBehaviours/#framesyncbehaviours","text":"The FrameSyncBehaviour class derives from MonoBehaviour . It acts as the unique identifier of a GameObject. All of the networked GameObjects should have a FrameSyncBehaviour component. Info To implement game logic and to store game states, implement IFrameSyncStart , IFrameSyncPlayerUpdate , IFrameSyncComputerUpdate , and IFrameSyncDataContainer interfaces in your MonoBehaviour component scripts and attach them to your networked GameObjects.","title":"FrameSyncBehaviours"},{"location":"frameSync/frameSyncBehaviours/#staticframesyncbehaviours","text":"Designed for GameObjects that are not dynamically instantiated or destroyed. If a GameObject is instantiated or destroyed at runtime, DynamicFrameSyncBehaviour should be used.","title":"StaticFrameSyncBehaviours"},{"location":"frameSync/frameSyncBehaviours/#dynamicframesyncbehaviours","text":"Designed for GameObjects that are dynamically instantiated or destroyed. Info DynamicFrameSyncBehaviour components will be automatically added to the GameObjects created at runtime. You don't need to add it to your prefabs.","title":"DynamicFrameSyncBehaviours"},{"location":"frameSync/frameSyncBehaviours/#properties","text":"Name Function Frame Sync Owner The owner of the FrameSyncBehaviour . For StaticFrameSyncBehaviour , its owner should be set in the editor. For DynamicFrameSyncBehaviour , it's owner is set on creation. Large Data Container By default, a FrameSyncBehaviour can contain up to 256 bytes of data. If Large Data Container is enabled, the limit is increased to 4096 bytes. id The UInt32 unique identifier of the GameObject. The property is for debug purpose and is readonly.","title":"Properties"},{"location":"frameSync/framesync/","text":"Overview \u00b6 A library for creating real-time multiplayer games with Unity. The library exchanges and manages players inputs. The synchronization of game states is achieved based on full deterministic simulation. The library verifies the simulation results of players in the same room to prevent cheating and desyncs. Advantages \u00b6 Low bandwidth usage : scales as the size of the inputs and the number of players Networked physics : works out of the box with our 2D and 3D physics engine. Cheat prevention : simulation results are hashed and compared periodically. Lag compensation : responsive gameplay when running in the prediction/rollback mode. Offline Mode \u00b6 Designed for local split screen games and single player mode, also useful for developing games offline. Lockstep Mode \u00b6 Designed for RTS, MOBA games that a lot of gameobjects need to be synchronized. Prediction/Rollback Mode \u00b6 Designed for vehicle simulation, Fighting and FPS games that are fast-paced and sensitive to network latency.","title":"Overview"},{"location":"frameSync/framesync/#overview","text":"A library for creating real-time multiplayer games with Unity. The library exchanges and manages players inputs. The synchronization of game states is achieved based on full deterministic simulation. The library verifies the simulation results of players in the same room to prevent cheating and desyncs.","title":"Overview"},{"location":"frameSync/framesync/#advantages","text":"Low bandwidth usage : scales as the size of the inputs and the number of players Networked physics : works out of the box with our 2D and 3D physics engine. Cheat prevention : simulation results are hashed and compared periodically. Lag compensation : responsive gameplay when running in the prediction/rollback mode.","title":"Advantages"},{"location":"frameSync/framesync/#offline-mode","text":"Designed for local split screen games and single player mode, also useful for developing games offline.","title":"Offline Mode"},{"location":"frameSync/framesync/#lockstep-mode","text":"Designed for RTS, MOBA games that a lot of gameobjects need to be synchronized.","title":"Lockstep Mode"},{"location":"frameSync/framesync/#predictionrollback-mode","text":"Designed for vehicle simulation, Fighting and FPS games that are fast-paced and sensitive to network latency.","title":"Prediction/Rollback Mode"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/","text":"IFrameSyncComputerUpdate \u00b6 Declaration \u00b6 C# public interface IFrameSyncComputerUpdate { void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ); } Parameters \u00b6 Name frameSyncUpdateType The update type. Description \u00b6 Called by the FrameSyncEngine to update the computer owned FrameSyncBehaviour during frame simulation. Example \u00b6 C# public class ComputerMovement : MonoBehaviour , IFrameSyncComputerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { FFloat diretion = FFloat . zero ; if ( fTransform . position . y > FFloat . FromDivision ( 10 , 1 )) { diretion = - FFloat . one ; } else if ( fTransform . position . y < - FFloat . FromDivision ( 10 , 1 )) { diretion = FFloat . one ; } FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , diretion , FFloat . zero ); fTransform . position += displacement ; } }","title":"IFrameSyncComputerUpdate"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/#iframesynccomputerupdate","text":"","title":"IFrameSyncComputerUpdate"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/#declaration","text":"C# public interface IFrameSyncComputerUpdate { void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ); }","title":"Declaration"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/#parameters","text":"Name frameSyncUpdateType The update type.","title":"Parameters"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/#description","text":"Called by the FrameSyncEngine to update the computer owned FrameSyncBehaviour during frame simulation.","title":"Description"},{"location":"frameSync/GameLogic/IFrameSyncComputerUpdate/#example","text":"C# public class ComputerMovement : MonoBehaviour , IFrameSyncComputerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { FFloat diretion = FFloat . zero ; if ( fTransform . position . y > FFloat . FromDivision ( 10 , 1 )) { diretion = - FFloat . one ; } else if ( fTransform . position . y < - FFloat . FromDivision ( 10 , 1 )) { diretion = FFloat . one ; } FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , diretion , FFloat . zero ); fTransform . position += displacement ; } }","title":"Example"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/","text":"IFrameSyncOnStart \u00b6 Declaration \u00b6 C# public interface IFrameSyncStart { void OnStart ( FrameSyncBehaviour frameSyncBehaviour ); } Parameters \u00b6 Name frameSyncBehaviour The FrameSyncBehaviour component attached to the GameObject. Description \u00b6 Called before the first IFrameSyncPlayerUpdate and IFrameSyncComputerUpdate. Implement this interface to initialzie the component. Example \u00b6 C# public class MyGameManager : MonoBehaviour , IFrameSyncStart { FFloat [] values ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { values = new FFloat [ 10 ]; } }","title":"IFrameSyncOnStart"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/#iframesynconstart","text":"","title":"IFrameSyncOnStart"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/#declaration","text":"C# public interface IFrameSyncStart { void OnStart ( FrameSyncBehaviour frameSyncBehaviour ); }","title":"Declaration"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/#parameters","text":"Name frameSyncBehaviour The FrameSyncBehaviour component attached to the GameObject.","title":"Parameters"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/#description","text":"Called before the first IFrameSyncPlayerUpdate and IFrameSyncComputerUpdate. Implement this interface to initialzie the component.","title":"Description"},{"location":"frameSync/GameLogic/IFrameSyncOnStart/#example","text":"C# public class MyGameManager : MonoBehaviour , IFrameSyncStart { FFloat [] values ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { values = new FFloat [ 10 ]; } }","title":"Example"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/","text":"IFrameSyncPlayerUpdate \u00b6 Declaration \u00b6 C# public interface IFrameSyncPlayerUpdate { void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ); } Parameters \u00b6 Name player The owner of the FrameSyncBehaviour . frameSyncUpdateType The update type. Description \u00b6 Called by the FrameSyncEngine to update the player owned FrameSyncBehaviour during frame simulation. Example \u00b6 C# public class PlayerMovement : MonoBehaviour , IFrameSyncPlayerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { FFloat y = player . GetInputY (); FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); fTransform . position += displacement ; } }","title":"IFrameSyncPlayerUpdate"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/#iframesyncplayerupdate","text":"","title":"IFrameSyncPlayerUpdate"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/#declaration","text":"C# public interface IFrameSyncPlayerUpdate { void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ); }","title":"Declaration"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/#parameters","text":"Name player The owner of the FrameSyncBehaviour . frameSyncUpdateType The update type.","title":"Parameters"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/#description","text":"Called by the FrameSyncEngine to update the player owned FrameSyncBehaviour during frame simulation.","title":"Description"},{"location":"frameSync/GameLogic/IFrameSyncPlayerUpdate/#example","text":"C# public class PlayerMovement : MonoBehaviour , IFrameSyncPlayerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { FFloat y = player . GetInputY (); FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); fTransform . position += displacement ; } }","title":"Example"},{"location":"frameSync/GameLogic/IFrameSyncTimerEventHandler/","text":"","title":"IFrameSyncTimerEventHandler"},{"location":"frameSync/GameLogic/overview/","text":"Overview \u00b6 Seperation of Game Logic And Presentation \u00b6 Your game logic should only be implemented in the IFrameSync interfaces. All the Unity MonoBehaviour events/messages are considered indeterministic, you should use them for presentation only. Deterministic Description IFrameSyncOnStart Called before the first IFrameSyncPlayerUpdate and IFrameSyncComputerUpdate . Implement this interface to initialzie the component. IFrameSyncPlayerUpdate Called by the FrameSyncEngine to update the player owned FrameSyncBehaviour during frame simulation. IFrameSyncComputerUpdate Called by the FrameSyncEngine to update the computer owned FrameSyncBehaviour during frame simulation. IFrameSyncTimerEventHandler Called when a FrameSyncTimer event occurs. Indeterministic Description Start called when the GameObject begins to exist (either when the Scene is loaded, or the GameObject is instantiated). Update called every frame. FixedUpdate called every physics timestep. OnCollisionEnter and OnTriggerEnter called when physics collisions or triggers occur. Networked Input \u00b6 Before the frame simulation starts, the FrameSyncEngine reads the input data of the frame and assign the input values to the players. During a frame simulaiton, the FrameSyncEngine updates the FrameSyncBehaviour s and your IFrameSyncPlayerUpdate MonoBehaivours will be updated. The player that owns the FrameSyncBehaviour will be passed into the OnPlayerUpdate() method. You can read the inputs of the player by calling player.GetInput{InputName}() ; Info The player.GetInput{InputName}() method is generated when you save the InputSettings of the game. See InputSettings for more details. Example Script Showing The Seperation of Game Logic And Presentation \u00b6 C# public class MyExampleScript : MonoBehaviour , IFrameSyncOnStart , IFrameSyncPlayerUpdate { //Displays player's score in a label, not used in the Game Logic public Text playerScoreLabel ; //the player score, this value is used in the Game Logic int playerScore //==========Unity Events========== //only used to read playerScore and update the playerScoreLabel void Update () { playerScoreLabel . text = playerScore . ToString (); } //==========Game Logic========== //IFrameSyncOnStart //used for initialize the component public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { playerScore = 0 ; } //IFrameSyncPlayerUpdate //used to read player input and change player score public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { bool addScore = player . GetInputAddScore (); if ( addScore ) { playerScore ++; } } }","title":"Overview"},{"location":"frameSync/GameLogic/overview/#overview","text":"","title":"Overview"},{"location":"frameSync/GameLogic/overview/#seperation-of-game-logic-and-presentation","text":"Your game logic should only be implemented in the IFrameSync interfaces. All the Unity MonoBehaviour events/messages are considered indeterministic, you should use them for presentation only. Deterministic Description IFrameSyncOnStart Called before the first IFrameSyncPlayerUpdate and IFrameSyncComputerUpdate . Implement this interface to initialzie the component. IFrameSyncPlayerUpdate Called by the FrameSyncEngine to update the player owned FrameSyncBehaviour during frame simulation. IFrameSyncComputerUpdate Called by the FrameSyncEngine to update the computer owned FrameSyncBehaviour during frame simulation. IFrameSyncTimerEventHandler Called when a FrameSyncTimer event occurs. Indeterministic Description Start called when the GameObject begins to exist (either when the Scene is loaded, or the GameObject is instantiated). Update called every frame. FixedUpdate called every physics timestep. OnCollisionEnter and OnTriggerEnter called when physics collisions or triggers occur.","title":"Seperation of Game Logic And Presentation"},{"location":"frameSync/GameLogic/overview/#networked-input","text":"Before the frame simulation starts, the FrameSyncEngine reads the input data of the frame and assign the input values to the players. During a frame simulaiton, the FrameSyncEngine updates the FrameSyncBehaviour s and your IFrameSyncPlayerUpdate MonoBehaivours will be updated. The player that owns the FrameSyncBehaviour will be passed into the OnPlayerUpdate() method. You can read the inputs of the player by calling player.GetInput{InputName}() ; Info The player.GetInput{InputName}() method is generated when you save the InputSettings of the game. See InputSettings for more details.","title":"Networked Input"},{"location":"frameSync/GameLogic/overview/#example-script-showing-the-seperation-of-game-logic-and-presentation","text":"C# public class MyExampleScript : MonoBehaviour , IFrameSyncOnStart , IFrameSyncPlayerUpdate { //Displays player's score in a label, not used in the Game Logic public Text playerScoreLabel ; //the player score, this value is used in the Game Logic int playerScore //==========Unity Events========== //only used to read playerScore and update the playerScoreLabel void Update () { playerScoreLabel . text = playerScore . ToString (); } //==========Game Logic========== //IFrameSyncOnStart //used for initialize the component public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { playerScore = 0 ; } //IFrameSyncPlayerUpdate //used to read player input and change player score public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { bool addScore = player . GetInputAddScore (); if ( addScore ) { playerScore ++; } } }","title":"Example Script Showing The Seperation of Game Logic And Presentation"},{"location":"frameSync/GameStates/IFrameSyncDataContainer/","text":"IFrameSyncDataContainer \u00b6 Declaration \u00b6 C# public interface IFrameSyncDataContainer { void OnImport ( SWBytes buffer ); void OnExport ( SWBytes buffer ); } Description \u00b6 Called by the FrameSyncEngine to export/import the data of the FrameSyncBehaviour . You should implement this interface in a MonoBehaviour component if it contains game states that needs to be restored for deterministic simulation after a rollback and Example \u00b6 C# public class PlayerMovement : MonoBehaviour , IFrameSyncPlayerUpdate , IFrameSyncDataContainer { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnExport ( SWBytes buffer ) { buffer . Push ( fTransform . position . y ); } public void OnImport ( SWBytes buffer ) { FFloat y = buffer . PopFFloat (); FVector3 pos = fTransform . position ; fTransform . position = new FVector3 ( pos . x , y , pos . z ); } public FrameSyncDebugItemGroup OnExportDebugInfo () { FrameSyncDebugItemGroup group = new FrameSyncDebugItemGroup (); group . name = \"PlayerMovement\" ; group . Add ( \"y\" , fTransform . position . y . ToString ()); return group ; } public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncUpdateType frameSyncUpdateType ) { FFloat y = player . GetInputY (); FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); fTransform . position += displacement ; } }","title":"IFrameSyncDataContainer"},{"location":"frameSync/GameStates/IFrameSyncDataContainer/#iframesyncdatacontainer","text":"","title":"IFrameSyncDataContainer"},{"location":"frameSync/GameStates/IFrameSyncDataContainer/#declaration","text":"C# public interface IFrameSyncDataContainer { void OnImport ( SWBytes buffer ); void OnExport ( SWBytes buffer ); }","title":"Declaration"},{"location":"frameSync/GameStates/IFrameSyncDataContainer/#description","text":"Called by the FrameSyncEngine to export/import the data of the FrameSyncBehaviour . You should implement this interface in a MonoBehaviour component if it contains game states that needs to be restored for deterministic simulation after a rollback and","title":"Description"},{"location":"frameSync/GameStates/IFrameSyncDataContainer/#example","text":"C# public class PlayerMovement : MonoBehaviour , IFrameSyncPlayerUpdate , IFrameSyncDataContainer { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnExport ( SWBytes buffer ) { buffer . Push ( fTransform . position . y ); } public void OnImport ( SWBytes buffer ) { FFloat y = buffer . PopFFloat (); FVector3 pos = fTransform . position ; fTransform . position = new FVector3 ( pos . x , y , pos . z ); } public FrameSyncDebugItemGroup OnExportDebugInfo () { FrameSyncDebugItemGroup group = new FrameSyncDebugItemGroup (); group . name = \"PlayerMovement\" ; group . Add ( \"y\" , fTransform . position . y . ToString ()); return group ; } public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncUpdateType frameSyncUpdateType ) { FFloat y = player . GetInputY (); FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); fTransform . position += displacement ; } }","title":"Example"},{"location":"frameSync/GameStates/IFrameSyncSnapshot/","text":"IFrameSyncSnapshot \u00b6 Declaration \u00b6 C# public interface IFrameSyncSnapshot { void Restore (); void Clear (); SWBytes Export (); } Description \u00b6 Designed for game states that are not owned by a FrameSyncBehaviour . For game states owned by a FrameSyncBehaviour , implement IFrameSyncDataContainer in a MonoBehaviour component and attach it to the GameObject. Example \u00b6 In this example, we created Physics2DSnapshot that implements the IFrameSyncSnapshot interface. C# public class Physics2DSnapshot : IFrameSyncSnapshot { FSnapshot2D snapshot2D ; public int frameNumber { get ; } public Physics2DSnapshot ( int frameNumber ) { snapshot2D = FPhysics2D . Snapshot (); this . frameNumber = frameNumber ; } public Physics2DSnapshot ( int frameNumber , byte [] bytes ) { snapshot2D = FPhysics2D . ImportSnapshot ( bytes , bytes . Length ); this . frameNumber = frameNumber ; } //=============== IFrameSyncSnapshot =============== //FrameSyncEngine won't need this IFrameSyncSnapshot anymore. //release resource if necessary. public void Clear () { if ( snapshot2D != null ) { FPhysics2D . DestroySnapshot ( snapshot2D ); snapshot2D = null ; } } //FrameSyncEngine will restore the game states using this IFrameSyncSnapshot public void Restore () { FPhysics2D . Restore ( snapshot2D ); } //Used only when other clients need a copy of this IFrameSyncSnapshot. //The SWBytes will be send to the other clients to restore game states. //This happens: //1: when other clients connect to the game and need to restore game states. //2: when desyncs are detected on other clients. public SWBytes Export () { byte [] bytes = new byte [ 1014 ]; int size = FPhysics2D . ExportSnapshot ( snapshot2D , bytes , 1024 ); SWBytes b = new SWBytes ( size ); b . Push ( bytes , size ); return b ; } } The Physics2DSnapshot object is used by the FrameSyncEngine to restore the states in the FPhysics2D world. C# public class MyFrameSyncEngineController : FrameSyncEngineController { . . . protected override IFrameSyncSnapshot OnFrameSyncCreateCustomRestorable ( int frameNumber ) { return new Physics2DSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomRestorable ( int frameNumber , byte [] bytes ) { return new Physics2DSnapshot ( frameNumber , bytes ); } }","title":"IFrameSyncSnapshot"},{"location":"frameSync/GameStates/IFrameSyncSnapshot/#iframesyncsnapshot","text":"","title":"IFrameSyncSnapshot"},{"location":"frameSync/GameStates/IFrameSyncSnapshot/#declaration","text":"C# public interface IFrameSyncSnapshot { void Restore (); void Clear (); SWBytes Export (); }","title":"Declaration"},{"location":"frameSync/GameStates/IFrameSyncSnapshot/#description","text":"Designed for game states that are not owned by a FrameSyncBehaviour . For game states owned by a FrameSyncBehaviour , implement IFrameSyncDataContainer in a MonoBehaviour component and attach it to the GameObject.","title":"Description"},{"location":"frameSync/GameStates/IFrameSyncSnapshot/#example","text":"In this example, we created Physics2DSnapshot that implements the IFrameSyncSnapshot interface. C# public class Physics2DSnapshot : IFrameSyncSnapshot { FSnapshot2D snapshot2D ; public int frameNumber { get ; } public Physics2DSnapshot ( int frameNumber ) { snapshot2D = FPhysics2D . Snapshot (); this . frameNumber = frameNumber ; } public Physics2DSnapshot ( int frameNumber , byte [] bytes ) { snapshot2D = FPhysics2D . ImportSnapshot ( bytes , bytes . Length ); this . frameNumber = frameNumber ; } //=============== IFrameSyncSnapshot =============== //FrameSyncEngine won't need this IFrameSyncSnapshot anymore. //release resource if necessary. public void Clear () { if ( snapshot2D != null ) { FPhysics2D . DestroySnapshot ( snapshot2D ); snapshot2D = null ; } } //FrameSyncEngine will restore the game states using this IFrameSyncSnapshot public void Restore () { FPhysics2D . Restore ( snapshot2D ); } //Used only when other clients need a copy of this IFrameSyncSnapshot. //The SWBytes will be send to the other clients to restore game states. //This happens: //1: when other clients connect to the game and need to restore game states. //2: when desyncs are detected on other clients. public SWBytes Export () { byte [] bytes = new byte [ 1014 ]; int size = FPhysics2D . ExportSnapshot ( snapshot2D , bytes , 1024 ); SWBytes b = new SWBytes ( size ); b . Push ( bytes , size ); return b ; } } The Physics2DSnapshot object is used by the FrameSyncEngine to restore the states in the FPhysics2D world. C# public class MyFrameSyncEngineController : FrameSyncEngineController { . . . protected override IFrameSyncSnapshot OnFrameSyncCreateCustomRestorable ( int frameNumber ) { return new Physics2DSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomRestorable ( int frameNumber , byte [] bytes ) { return new Physics2DSnapshot ( frameNumber , bytes ); } }","title":"Example"},{"location":"frameSync/frameSyncEngine/frameSyncEngineController/","text":"FrameSyncEngineController \u00b6 Your code interacts with the FrameSyncEngine by implementing a class derives from the built-in class FrameSyncEngineController . Properties \u00b6 Name Function Engine Mode FrameSyncEngine mode, the options are: Offline , Online , and OnlineRollback . Input Settings The input settings ScriptableObject. Prefab Registry The Prefab Registry ScriptableObject. Offline Player Count The number of players in offline mode. Show Stats If enabled, FrameDelay , InputDelay and Frame Buffered will be displayed at the top left corner. Interaction with Unity \u00b6 The base FrameSyncEngineController is a subclass of MonoBehaviour and implements the Awake() , Start() , FixedUpdate() , Update() , OnDestroy() , and OnGUI() methods. Please see the chart below. Info Different FrameSyncEngine modes have different FrameSync runloop execution order. Please check Offline Mode , Online Mode , Prediction/Rollback Mode for details. Events \u00b6 The FrameSyncEngineController provides a collection of useful events which allow you to customize the behaviour of the FrameSyncEngine for your game. Input Sample Events OnFrameSyncCollectPlayerInput Called when the FrameSyncEngine samples the inputs of the local player. Player Status Change Events OnFrameSyncNewPlayerConnected Called when a player connects to the room. OnFrameSyncPlayerReconnected Called when a player reconnects to the room. OnFrameSyncPlayerDisconnected Called when a player disconnects. Desync Detection Events OnFrameSyncDesyncDetected Called when a simulation desync is detected. By default, the method returns false. Simulation Events OnFrameSyncFinishedSimulationForCurrentFrame Called after the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours finished simulation for the current FrameSync step. OnFrameSyncWillFinishCurrentFrame Called before the current Frame finishes. Custom Restorable Events OnFrameSyncCreateCustomRestorable Called after the FrameSyncEngine exported the data from the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours. OnFrameSyncWillUseCustomRestorable Called before the FrameSyncEngine uses a custom IFrameSyncSnapshot object for restoration. OnFrameSyncImportCustomRestorable Called when importing game states data from server. Custom Hashcode Events OnFrameSyncGetCustomHashCode Called when calculating a hash for the current simulation step. Game State Restoration Events OnFrameSyncWillRestoreGameStates Called when the client connects to a game and needs to restore the game states OnFrameSyncDidCreateGameObjectForRestoration Called after the FrameSyncEngine creates a GameObject for restoration. OnFrameSyncWillDestroyGameObjectForRestoration Called before the FrameSyncEngine destroys a GameObject for restoration. FrameSyncGame Events OnFrameSyncGameStateChanged Called when the FrameSyncGame state changes. OnFrameSyncGameInitialize Called before the FrameSyncGame starts.","title":"FrameSyncEngineController"},{"location":"frameSync/frameSyncEngine/frameSyncEngineController/#framesyncenginecontroller","text":"Your code interacts with the FrameSyncEngine by implementing a class derives from the built-in class FrameSyncEngineController .","title":"FrameSyncEngineController"},{"location":"frameSync/frameSyncEngine/frameSyncEngineController/#properties","text":"Name Function Engine Mode FrameSyncEngine mode, the options are: Offline , Online , and OnlineRollback . Input Settings The input settings ScriptableObject. Prefab Registry The Prefab Registry ScriptableObject. Offline Player Count The number of players in offline mode. Show Stats If enabled, FrameDelay , InputDelay and Frame Buffered will be displayed at the top left corner.","title":"Properties"},{"location":"frameSync/frameSyncEngine/frameSyncEngineController/#interaction-with-unity","text":"The base FrameSyncEngineController is a subclass of MonoBehaviour and implements the Awake() , Start() , FixedUpdate() , Update() , OnDestroy() , and OnGUI() methods. Please see the chart below. Info Different FrameSyncEngine modes have different FrameSync runloop execution order. Please check Offline Mode , Online Mode , Prediction/Rollback Mode for details.","title":"Interaction with Unity"},{"location":"frameSync/frameSyncEngine/frameSyncEngineController/#events","text":"The FrameSyncEngineController provides a collection of useful events which allow you to customize the behaviour of the FrameSyncEngine for your game. Input Sample Events OnFrameSyncCollectPlayerInput Called when the FrameSyncEngine samples the inputs of the local player. Player Status Change Events OnFrameSyncNewPlayerConnected Called when a player connects to the room. OnFrameSyncPlayerReconnected Called when a player reconnects to the room. OnFrameSyncPlayerDisconnected Called when a player disconnects. Desync Detection Events OnFrameSyncDesyncDetected Called when a simulation desync is detected. By default, the method returns false. Simulation Events OnFrameSyncFinishedSimulationForCurrentFrame Called after the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours finished simulation for the current FrameSync step. OnFrameSyncWillFinishCurrentFrame Called before the current Frame finishes. Custom Restorable Events OnFrameSyncCreateCustomRestorable Called after the FrameSyncEngine exported the data from the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours. OnFrameSyncWillUseCustomRestorable Called before the FrameSyncEngine uses a custom IFrameSyncSnapshot object for restoration. OnFrameSyncImportCustomRestorable Called when importing game states data from server. Custom Hashcode Events OnFrameSyncGetCustomHashCode Called when calculating a hash for the current simulation step. Game State Restoration Events OnFrameSyncWillRestoreGameStates Called when the client connects to a game and needs to restore the game states OnFrameSyncDidCreateGameObjectForRestoration Called after the FrameSyncEngine creates a GameObject for restoration. OnFrameSyncWillDestroyGameObjectForRestoration Called before the FrameSyncEngine destroys a GameObject for restoration. FrameSyncGame Events OnFrameSyncGameStateChanged Called when the FrameSyncGame state changes. OnFrameSyncGameInitialize Called before the FrameSyncGame starts.","title":"Events"},{"location":"frameSync/frameSyncEngine/networkedInputs/","text":"","title":"networkedInputs"},{"location":"frameSync/frameSyncEngine/offline/","text":"Offline Mode \u00b6 Designed for local split screen games and single player mode, also useful for developing the game offline. FrameSync Runloop Execution Order \u00b6","title":"Offline Mode"},{"location":"frameSync/frameSyncEngine/offline/#offline-mode","text":"Designed for local split screen games and single player mode, also useful for developing the game offline.","title":"Offline Mode"},{"location":"frameSync/frameSyncEngine/offline/#framesync-runloop-execution-order","text":"","title":"FrameSync Runloop Execution Order"},{"location":"frameSync/frameSyncEngine/online/","text":"","title":"Online Mode"},{"location":"frameSync/frameSyncEngine/rollback/","text":"","title":"Rollback Mode"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncCollectPlayerInput/","text":"","title":"OnFrameSyncCollectPlayerInput"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncCreateCustomRestorable/","text":"","title":"OnFrameSyncCreateCustomRestorable"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncDesyncDetected/","text":"","title":"OnFrameSyncDesyncDetected"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncDidCreateGameObjectForRestoration/","text":"","title":"OnFrameSyncDidCreateGameObjectForRestoration"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncFinishedSimulationForCurrentFrame/","text":"","title":"OnFrameSyncFinishedSimulationForCurrentFrame"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncGameInitialize/","text":"","title":"OnFrameSyncGameInitialize"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncGameStateChanged/","text":"","title":"OnFrameSyncGameStateChanged"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncGetCustomHashCode/","text":"","title":"OnFrameSyncGetCustomHashCode"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncImportCustomRestorable/","text":"","title":"OnFrameSyncImportCustomRestorable"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncNewPlayerConnected/","text":"","title":"OnFrameSyncNewPlayerConnected"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncPlayerDisconnected/","text":"","title":"OnFrameSyncPlayerDisconnected"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncPlayerReconnected/","text":"","title":"OnFrameSyncPlayerReconnected"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncWillDestroyGameObjectForRestoration/","text":"","title":"OnFrameSyncWillDestroyGameObjectForRestoration"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncWillFinishCurrentFrame/","text":"","title":"OnFrameSyncWillFinishCurrentFrame"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncWillRestoreGameStates/","text":"","title":"OnFrameSyncWillRestoreGameStates"},{"location":"frameSync/frameSyncEngine/events/OnFrameSyncWillUseCustomRestorable/","text":"","title":"OnFrameSyncWillUseCustomRestorable"},{"location":"frameSync/importantClass/frameSyncAgent/","text":"FrameSyncAgent \u00b6 Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } } Events \u00b6 The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game. OnFrameSyncEngineCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. OnFrameSyncGameCreated \u00b6 Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. OnCollectLocalPlayerInputs \u00b6 Called every frame to collect the inputs of the local player.","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#framesyncagent","text":"Your code interacts with the FrameSyncEngine and the FrameSyncGame by implementing a class derives from the build-in class called FrameSyncAgent . The FrameSyncAgent class is derived from the Unity MonoBehaviour class, and it creates a FrameSyncEngine and a FrameSyncGame in its Awake() method. Example contents of a FrameSyncAgent subclass: C# using UnityEngine ; using SWNetwork.FrameSync ; public class MyFrameSyncAgent : FrameSyncAgent { public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"FrameSyncAgent"},{"location":"frameSync/importantClass/frameSyncAgent/#events","text":"The FrameSyncAgent class provides a collection of useful events which allows you to customize the FrameSync build-in classes for your game.","title":"Events"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncenginecreated","text":"Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method.","title":"OnFrameSyncEngineCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#onframesyncgamecreated","text":"Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method.","title":"OnFrameSyncGameCreated"},{"location":"frameSync/importantClass/frameSyncAgent/#oncollectlocalplayerinputs","text":"Called every frame to collect the inputs of the local player.","title":"OnCollectLocalPlayerInputs"},{"location":"home/installation/","text":"Welcome to FrameSync \u00b6 Installation \u00b6 https://gitee.com/kcezorro/parallel-up.git https://gitee.com/kcezorro/frame-sync-up.git https://gitee.com/kcezorro/pathfinding-up.git https://gitee.com/kcezorro/frame-sync-debug-server.git https://gitee.com/kcezorro/frame-sync.git https://gitee.com/kcezorro/FPhysics3D.git https://gitee.com/kcezorro/fmath.git https://gitee.com/kcezorro/FPhysics2D.git","title":"Installation"},{"location":"home/installation/#welcome-to-framesync","text":"","title":"Welcome to FrameSync"},{"location":"home/installation/#installation","text":"https://gitee.com/kcezorro/parallel-up.git https://gitee.com/kcezorro/frame-sync-up.git https://gitee.com/kcezorro/pathfinding-up.git https://gitee.com/kcezorro/frame-sync-debug-server.git https://gitee.com/kcezorro/frame-sync.git https://gitee.com/kcezorro/FPhysics3D.git https://gitee.com/kcezorro/fmath.git https://gitee.com/kcezorro/FPhysics2D.git","title":"Installation"},{"location":"physics2d/parallelBoxCollider2D/","text":"Collider for 2D physics representing an axis-aligned rectangle.","title":"ParallelBoxCollider2D"},{"location":"physics2d/physics2D/","text":"Real-time rigidbody 2D physics based on Box2D. Classes \u00b6 Name Description ParallelBoxCollider2D Collider for 2D physics representing an axis-aligned rectangle. ParallelCapsuleCollider2D A capsule-shaped primitive collider. ParallelCircleCollider2D Collider for 2D physics representing an circle. ParallelCollider2D Parent class for collider types used with 2D gameplay. ParallelCollision2D Collision details returned by 2D physics callback functions. ParallelPhysics2D Global settings and helpers for 2D physics. ParallelPolygonCollider2D Collider for 2D physics representing an arbitrary polygon defined by its vertices. ParallelRigidbody2D Rigidbody physics component for 2D sprites. Structs \u00b6 Name Description Enumerations \u00b6","title":"Overview"},{"location":"physics2d/physics2D/#classes","text":"Name Description ParallelBoxCollider2D Collider for 2D physics representing an axis-aligned rectangle. ParallelCapsuleCollider2D A capsule-shaped primitive collider. ParallelCircleCollider2D Collider for 2D physics representing an circle. ParallelCollider2D Parent class for collider types used with 2D gameplay. ParallelCollision2D Collision details returned by 2D physics callback functions. ParallelPhysics2D Global settings and helpers for 2D physics. ParallelPolygonCollider2D Collider for 2D physics representing an arbitrary polygon defined by its vertices. ParallelRigidbody2D Rigidbody physics component for 2D sprites.","title":"Classes"},{"location":"physics2d/physics2D/#structs","text":"Name Description","title":"Structs"},{"location":"physics2d/physics2D/#enumerations","text":"","title":"Enumerations"},{"location":"tutorial/Pong2D/ballManager/","text":"Ball Manager \u00b6 Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncComputerUpdate interface. Drag the FTransform component and the FRigibody2D component of the Ball GameObject to the ballTransform and ballRigidbody field. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using SocketWeaver.FPhysics2D ; using UnityEngine ; namespace SWExample.Pong { public class BallManager : MonoBehaviour , IFrameSyncComputerUpdate { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public FFloat ballInitialSpeed = FFloat . FromDivision ( 5 , 1 ); public FFloat ballInitialSpeedXYRatio = FFloat . three ; public FFloat boundary = FFloat . FromDivision ( 11 , 1 ); public FTransform ballTransform ; public FRigidbody2D ballRigidbody ; public void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary for every FrameSync frame. if ( ballTransform . position . x < - boundary ) { //player 2 scored player2Score ++; ResetBall (); } else if ( ballTransform . position . x > boundary ) { //player 1 scored player1Score ++; ResetBall (); } } public void PlayerIsReady ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerIsReady player={player.playerId}\" ); if ( player . playerId == 1 ) { player1Ready = true ; } else { player2Ready = true ; } // fire the ball when both players are ready. if ( player1Ready && player2Ready ) { Kickoff (); } } void Kickoff () { // you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. // The FrameSyncRandom API generates deterministic random numbers so players will get the same random numbers across the network. FFloat x = FrameSyncRandom . Range ( FFloat . negOne , FFloat . one ) * ballInitialSpeedXYRatio ; FFloat y = FrameSyncRandom . Range ( FFloat . negOne , FFloat . one ); // use the random numbers to calculate the initial velocity of the ball. FVector2 direction = new FVector2 ( x , y ); Debug . Log ( $ \"Kickoff direction={direction}\" ); ballRigidbody . velocity = direction . normalized * ballInitialSpeed ; } void ResetBall () { // reset ball position and velocities. ballTransform . position = FVector3 . zero ; ballTransform . Teleport ( FVector3 . zero ); ballRigidbody . velocity = FVector2 . zero ; ballRigidbody . angularVelocity = FFloat . zero ; // reset players ready flag. So they have to press the ready button again to continue. player1Ready = false ; player2Ready = false ; } } }","title":"Ball Manager"},{"location":"tutorial/Pong2D/ballManager/#ball-manager","text":"Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncComputerUpdate interface. Drag the FTransform component and the FRigibody2D component of the Ball GameObject to the ballTransform and ballRigidbody field. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using SocketWeaver.FPhysics2D ; using UnityEngine ; namespace SWExample.Pong { public class BallManager : MonoBehaviour , IFrameSyncComputerUpdate { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public FFloat ballInitialSpeed = FFloat . FromDivision ( 5 , 1 ); public FFloat ballInitialSpeedXYRatio = FFloat . three ; public FFloat boundary = FFloat . FromDivision ( 11 , 1 ); public FTransform ballTransform ; public FRigidbody2D ballRigidbody ; public void OnComputerUpdate ( FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary for every FrameSync frame. if ( ballTransform . position . x < - boundary ) { //player 2 scored player2Score ++; ResetBall (); } else if ( ballTransform . position . x > boundary ) { //player 1 scored player1Score ++; ResetBall (); } } public void PlayerIsReady ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerIsReady player={player.playerId}\" ); if ( player . playerId == 1 ) { player1Ready = true ; } else { player2Ready = true ; } // fire the ball when both players are ready. if ( player1Ready && player2Ready ) { Kickoff (); } } void Kickoff () { // you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. // The FrameSyncRandom API generates deterministic random numbers so players will get the same random numbers across the network. FFloat x = FrameSyncRandom . Range ( FFloat . negOne , FFloat . one ) * ballInitialSpeedXYRatio ; FFloat y = FrameSyncRandom . Range ( FFloat . negOne , FFloat . one ); // use the random numbers to calculate the initial velocity of the ball. FVector2 direction = new FVector2 ( x , y ); Debug . Log ( $ \"Kickoff direction={direction}\" ); ballRigidbody . velocity = direction . normalized * ballInitialSpeed ; } void ResetBall () { // reset ball position and velocities. ballTransform . position = FVector3 . zero ; ballTransform . Teleport ( FVector3 . zero ); ballRigidbody . velocity = FVector2 . zero ; ballRigidbody . angularVelocity = FFloat . zero ; // reset players ready flag. So they have to press the ready button again to continue. player1Ready = false ; player2Ready = false ; } } }","title":"Ball Manager"},{"location":"tutorial/Pong2D/frameSyncEngineController/","text":"FrameSyncEngineController \u00b6 The FrameSyncEngine is the core of the FrameSync library. You will create a subclass of the built-in FrameSyncEngineController to control the FrameSyncEninge. Create a new script and name it PongFrameSyncEngineController . Create a new empty GameObject and attach the PongFrameSyncEngineController to it. In the PongFrameSyncEngineController script, remove Start() and Update and add the following code. Drag the FPhysics2DManager into the physicsEngine field in the inspector. Drag the InputSettings asset into the Input Settings field. C# using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics2D ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public class PongFrameSyncEngineController : FrameSyncEngineController { //reference to the FPhysics2DManager public FPhysics2DManager physicsEngine ; //Called when the FrameSyncEngine samples the inputs of the local player protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { //set the inputs for the local player game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); game . localPlayer . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); } protected override void OnStart () { //manually initialize the physics engine physicsEngine . Initialize (); } //Called after the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours //finished simulation for the current FrameSync step protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { //manually update the physics engine physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"FrameSyncEngineController"},{"location":"tutorial/Pong2D/frameSyncEngineController/#framesyncenginecontroller","text":"The FrameSyncEngine is the core of the FrameSync library. You will create a subclass of the built-in FrameSyncEngineController to control the FrameSyncEninge. Create a new script and name it PongFrameSyncEngineController . Create a new empty GameObject and attach the PongFrameSyncEngineController to it. In the PongFrameSyncEngineController script, remove Start() and Update and add the following code. Drag the FPhysics2DManager into the physicsEngine field in the inspector. Drag the InputSettings asset into the Input Settings field. C# using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics2D ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public class PongFrameSyncEngineController : FrameSyncEngineController { //reference to the FPhysics2DManager public FPhysics2DManager physicsEngine ; //Called when the FrameSyncEngine samples the inputs of the local player protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { //set the inputs for the local player game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); game . localPlayer . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); } protected override void OnStart () { //manually initialize the physics engine physicsEngine . Initialize (); } //Called after the StaticFrameSyncBehaviours and the DynamicFrameSyncBehaviours //finished simulation for the current FrameSync step protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { //manually update the physics engine physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"FrameSyncEngineController"},{"location":"tutorial/Pong2D/gameScene/","text":"Get Started \u00b6 To get started, in the Project window, create a new folder under the Assets folder and name it Pong2D . All the assets used in this game will be created inside of this folder to make them easy to find. After that, create a new scene in the Pong2D folder and name it PongGame . Open the PongGame scene, select the Main Camera in the Hierarchy . Set Clear Flags to Solid Color Set Background to a color you like. Set Aspect ratio of the Game window to 16:9 .","title":"Get Started"},{"location":"tutorial/Pong2D/gameScene/#get-started","text":"To get started, in the Project window, create a new folder under the Assets folder and name it Pong2D . All the assets used in this game will be created inside of this folder to make them easy to find. After that, create a new scene in the Pong2D folder and name it PongGame . Open the PongGame scene, select the Main Camera in the Hierarchy . Set Clear Flags to Solid Color Set Background to a color you like. Set Aspect ratio of the Game window to 16:9 .","title":"Get Started"},{"location":"tutorial/Pong2D/inputSettings/","text":"Declare Inputs for Your Game \u00b6 The FrameSync library exchanges and manages player inputs. You will create an InputSettings scriptableObject to declare the inputs that your game uses. Creating an InputSettings ScriptableObject \u00b6 Right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings . Name the new asset FrameSyncInputSettings . Adding Inputs \u00b6 In this game, the player uses the Vertical Axis to move the paddle vertically and uses the G key to tell the game that they are ready to play. Select the FrameSyncInputSettings and configure it as shown below. Make sure that Name Space is set to SWExample.Pong which is the c# namespace of this game. Click the Save button. Info Extension methods will be generated under the provided namespace to help you get and set the inputs. You can see the generated code at Assets->SocketWeaver->framesync_generated_input->{Your namespace}","title":"Declare Inputs for Your Game"},{"location":"tutorial/Pong2D/inputSettings/#declare-inputs-for-your-game","text":"The FrameSync library exchanges and manages player inputs. You will create an InputSettings scriptableObject to declare the inputs that your game uses.","title":"Declare Inputs for Your Game"},{"location":"tutorial/Pong2D/inputSettings/#creating-an-inputsettings-scriptableobject","text":"Right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings . Name the new asset FrameSyncInputSettings .","title":"Creating an InputSettings ScriptableObject"},{"location":"tutorial/Pong2D/inputSettings/#adding-inputs","text":"In this game, the player uses the Vertical Axis to move the paddle vertically and uses the G key to tell the game that they are ready to play. Select the FrameSyncInputSettings and configure it as shown below. Make sure that Name Space is set to SWExample.Pong which is the c# namespace of this game. Click the Save button. Info Extension methods will be generated under the provided namespace to help you get and set the inputs. You can see the generated code at Assets->SocketWeaver->framesync_generated_input->{Your namespace}","title":"Adding Inputs"},{"location":"tutorial/Pong2D/overview/","text":"Overview \u00b6 Pong 2D is a fully functional multiplayer game made with Unity. It is deisgned to help you get started with the SocketWeaver FrameSync library. The tutorials should take less than 30 mintues to complete. In these step-by-step tutorials, you will: Use the FPhysics2D engine Create a classic pong game that is playable offline and online Create an InputSettings scriptableObject for your game Create a custom FrameSyncEngineController that samples local players inputs and updates the FPhsics2D engine. Read networked inputs Use the FrameSyncRandom API to generate deterministic pseudo random numbers By following these simple tutorials, you will learn the basics of the FrameSync library and will be ready to explore more advanced features that the library provides.","title":"Overview"},{"location":"tutorial/Pong2D/overview/#overview","text":"Pong 2D is a fully functional multiplayer game made with Unity. It is deisgned to help you get started with the SocketWeaver FrameSync library. The tutorials should take less than 30 mintues to complete. In these step-by-step tutorials, you will: Use the FPhysics2D engine Create a classic pong game that is playable offline and online Create an InputSettings scriptableObject for your game Create a custom FrameSyncEngineController that samples local players inputs and updates the FPhsics2D engine. Read networked inputs Use the FrameSyncRandom API to generate deterministic pseudo random numbers By following these simple tutorials, you will learn the basics of the FrameSync library and will be ready to explore more advanced features that the library provides.","title":"Overview"},{"location":"tutorial/Pong2D/paddleMovement/","text":"Paddle Movement \u00b6 Next, you will implement the paddle movement logic. Add a new script called PaddleMovement to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleMovement implements the IFrameSyncPlayerUpdate interface. Drag the FTransform component of the Paddle GameObject to the fTransform field in the inspector. C# using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public class PaddleMovement : MonoBehaviour , IFrameSyncPlayerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { //read the y input of the paddle owner player FFloat y = player . GetInputY (); //calculate the displacement for the frame FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); //update the position of the paddle fTransform . position += displacement ; //read the ready input for the paddle owner player if ( player . GetInputReady ()) { //notify the BallManager that the player is ready BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( player ); } } } }","title":"Paddle Movement"},{"location":"tutorial/Pong2D/paddleMovement/#paddle-movement","text":"Next, you will implement the paddle movement logic. Add a new script called PaddleMovement to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleMovement implements the IFrameSyncPlayerUpdate interface. Drag the FTransform component of the Paddle GameObject to the fTransform field in the inspector. C# using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Pong { public class PaddleMovement : MonoBehaviour , IFrameSyncPlayerUpdate { public FFloat speed = FFloat . FromDivision ( 5 , 1 ); public FTransform fTransform ; public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game , FrameSyncUpdateType frameSyncUpdateType ) { //read the y input of the paddle owner player FFloat y = player . GetInputY (); //calculate the displacement for the frame FVector3 displacement = speed * FrameSyncTime . fixedDeltaTime * new FVector3 ( FFloat . zero , y , FFloat . zero ); //update the position of the paddle fTransform . position += displacement ; //read the ready input for the paddle owner player if ( player . GetInputReady ()) { //notify the BallManager that the player is ready BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( player ); } } } }","title":"Paddle Movement"},{"location":"tutorial/Pong2D/playOffline/","text":"Playing Offline \u00b6 In this section, you will add support for playing the game offline. Go to Edit->ProjectSettings->Input manager . Right-Click the input Vertical and Duplicate Array Element . Name the new input Vertica1 . Remove the Alt Negative Button and Alt Positive Button of the the old Vertical input. Remove the Alt Negative Button and Alt Positive Button of the the new Vertical1 input. Set Negative Button to s and Positive Button to w for the old Vertical input. Set Negative Button to down and Positive Button to up for the new Vertical1 input. Next, select the PongFrameSyncEngineController component, set Engine Mode to Offline and Offline Player Count to 2. Update the OnFrameSyncCollectPlayerInput method of PongFrameSyncEngineController . C# protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { //player1 and player2 are created because we set Offline Player Count to 2. FrameSyncPlayer player1 = game . GetPlayer ( 1 ); FrameSyncPlayer player2 = game . GetPlayer ( 2 ); //player1 uses w and s to move and uses g to trigger the ready event. player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); player1 . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); //player2 uses up arrow and down arrow to move and uses h to trigger the ready event. player2 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical1\" )); player2 . SetInputReady ( Input . GetKeyUp ( KeyCode . H )); } else { game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); game . localPlayer . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); } } Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/Pong2D/playOffline/#playing-offline","text":"In this section, you will add support for playing the game offline. Go to Edit->ProjectSettings->Input manager . Right-Click the input Vertical and Duplicate Array Element . Name the new input Vertica1 . Remove the Alt Negative Button and Alt Positive Button of the the old Vertical input. Remove the Alt Negative Button and Alt Positive Button of the the new Vertical1 input. Set Negative Button to s and Positive Button to w for the old Vertical input. Set Negative Button to down and Positive Button to up for the new Vertical1 input. Next, select the PongFrameSyncEngineController component, set Engine Mode to Offline and Offline Player Count to 2. Update the OnFrameSyncCollectPlayerInput method of PongFrameSyncEngineController . C# protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { //player1 and player2 are created because we set Offline Player Count to 2. FrameSyncPlayer player1 = game . GetPlayer ( 1 ); FrameSyncPlayer player2 = game . GetPlayer ( 2 ); //player1 uses w and s to move and uses g to trigger the ready event. player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); player1 . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); //player2 uses up arrow and down arrow to move and uses h to trigger the ready event. player2 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical1\" )); player2 . SetInputReady ( Input . GetKeyUp ( KeyCode . H )); } else { game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); game . localPlayer . SetInputReady ( Input . GetKeyUp ( KeyCode . G )); } } Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/Pong2D/playOnline/","text":"Playing Online \u00b6 In this section, you will connect to the SocketWeaver cloud service to play online. Installing ParrelSync \u00b6 To make developing multiplayer games easy with Unit, install the ParrelSync unitypackage from https://github.com/VeriorPies/ParrelSync . It will save you a lot of time. We highly recommend it! Launch Another Instance of The Unity Editor \u00b6 Once you installed ParrelSync, Select ParrelSync->Clones Manager->Add new clone , and select Open in New Editor after the clone is created. FrameSync Demo Lobby Scene \u00b6 You will use the demo lobby scene that comes with the library to handle the matchmaking of the game. Open the Lobby scene. Select the Lobby GameObject and set Scene Name to PongGame . By setting Scene Name to PongGame , The demo lobby scene will navigate to the PongGame scene after when the connection to the cloud service is ready. Info Make sure to add the PongGame scene to the build settings. Info Make sure to change the Engine Mode of the PongFrameSyncEngineController to Online . Move the Unity Editors side by side. Now, you can play the game online. Hit play! Enter 1 as the playerID for player1 and enter 2 as the playerID for player2.","title":"Playing Online"},{"location":"tutorial/Pong2D/playOnline/#playing-online","text":"In this section, you will connect to the SocketWeaver cloud service to play online.","title":"Playing Online"},{"location":"tutorial/Pong2D/playOnline/#installing-parrelsync","text":"To make developing multiplayer games easy with Unit, install the ParrelSync unitypackage from https://github.com/VeriorPies/ParrelSync . It will save you a lot of time. We highly recommend it!","title":"Installing ParrelSync"},{"location":"tutorial/Pong2D/playOnline/#launch-another-instance-of-the-unity-editor","text":"Once you installed ParrelSync, Select ParrelSync->Clones Manager->Add new clone , and select Open in New Editor after the clone is created.","title":"Launch Another Instance of The Unity Editor"},{"location":"tutorial/Pong2D/playOnline/#framesync-demo-lobby-scene","text":"You will use the demo lobby scene that comes with the library to handle the matchmaking of the game. Open the Lobby scene. Select the Lobby GameObject and set Scene Name to PongGame . By setting Scene Name to PongGame , The demo lobby scene will navigate to the PongGame scene after when the connection to the cloud service is ready. Info Make sure to add the PongGame scene to the build settings. Info Make sure to change the Engine Mode of the PongFrameSyncEngineController to Online . Move the Unity Editors side by side. Now, you can play the game online. Hit play! Enter 1 as the playerID for player1 and enter 2 as the playerID for player2.","title":"FrameSync Demo Lobby Scene"},{"location":"tutorial/Pong2D/setup/","text":"Set Up The Scene \u00b6 Pong features two paddles, a ball and walls that confine the ball. In this section, you will create them using FPhysics2D. FPhysics2DManager \u00b6 For your first step, you will create a FPhysics2DManager . Right-Click in the Hierarchy window and select SocketWeaver->FPhysics->2D->Physics Controller . The FPhysics2DManager controls the FPhysics engine and manages rigidbodies in the scene. Disable Auto Initialize and Auto Update because you will manually initialize the FPhysics engine and manually update it. Rigidbodies \u00b6 Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move Ball \u00b6 Select SocketWeaver->FPhysics->2D->Circle . A circle should be created at (0, 0, 0). Select the circle and name it Ball . Select the FCircleCollider of the Ball and set Bounciness to 1. Paddles \u00b6 Select SocketWeaver->FPhysics->2D->Box . A box should be created. Select the box and name it Paddle . Move the Paddle to (-10, 0, 0). Set the Scale of the Paddle to (1, 3, 1). Select the FBoxCollider2D of the Paddle and set Bounciness to 1. Select the FRigidbody2D of the Paddle and set BodyType to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0). Walls \u00b6 Select SocketWeaver->FPhysics->2D->Box . Select the box and name it Wall . Move the Wall to (0, 6, 0). Set the Scale of Wall to (21, 1, 1). Select the FRigidbody2D of the Wall and set BodyType to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -6, 0). Final Touch \u00b6 You can change the color of the sprite to your liking. The scene should look like.","title":"Set Up The Scene"},{"location":"tutorial/Pong2D/setup/#set-up-the-scene","text":"Pong features two paddles, a ball and walls that confine the ball. In this section, you will create them using FPhysics2D.","title":"Set Up The Scene"},{"location":"tutorial/Pong2D/setup/#fphysics2dmanager","text":"For your first step, you will create a FPhysics2DManager . Right-Click in the Hierarchy window and select SocketWeaver->FPhysics->2D->Physics Controller . The FPhysics2DManager controls the FPhysics engine and manages rigidbodies in the scene. Disable Auto Initialize and Auto Update because you will manually initialize the FPhysics engine and manually update it.","title":"FPhysics2DManager"},{"location":"tutorial/Pong2D/setup/#rigidbodies","text":"Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move","title":"Rigidbodies"},{"location":"tutorial/Pong2D/setup/#ball","text":"Select SocketWeaver->FPhysics->2D->Circle . A circle should be created at (0, 0, 0). Select the circle and name it Ball . Select the FCircleCollider of the Ball and set Bounciness to 1.","title":"Ball"},{"location":"tutorial/Pong2D/setup/#paddles","text":"Select SocketWeaver->FPhysics->2D->Box . A box should be created. Select the box and name it Paddle . Move the Paddle to (-10, 0, 0). Set the Scale of the Paddle to (1, 3, 1). Select the FBoxCollider2D of the Paddle and set Bounciness to 1. Select the FRigidbody2D of the Paddle and set BodyType to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0).","title":"Paddles"},{"location":"tutorial/Pong2D/setup/#walls","text":"Select SocketWeaver->FPhysics->2D->Box . Select the box and name it Wall . Move the Wall to (0, 6, 0). Set the Scale of Wall to (21, 1, 1). Select the FRigidbody2D of the Wall and set BodyType to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -6, 0).","title":"Walls"},{"location":"tutorial/Pong2D/setup/#final-touch","text":"You can change the color of the sprite to your liking. The scene should look like.","title":"Final Touch"},{"location":"tutorial/Pong2D/staticFrameSyncBehaviour/","text":"StaticFrameSyncBehaviour \u00b6 The StaticFrameSyncBehaviour is the unique identifier of a GameObject. It helps the FrameSyncEngine to identify a networked GameObjec. Which GameObjects should have a StaticFrameSyncBehaviour? \u00b6 You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position is networked, so we should add StaticFrameSyncBehaviour to them. For the Ball, its position is updated by physics and is networked. so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their states do not change so we do not need to add StaticFrameSyncBehaviour to them. Adding the StaticFrameSyncBehaviour component \u00b6 Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour . StaticFrameSyncBehaviour Owner \u00b6 Select the left paddle and set its Frame Sync Owner to player1 . Select the right paddle and set its Frame Sync Owner to player2 . Select the ball and set its Frame Sync Owner to computer .","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/Pong2D/staticFrameSyncBehaviour/#staticframesyncbehaviour","text":"The StaticFrameSyncBehaviour is the unique identifier of a GameObject. It helps the FrameSyncEngine to identify a networked GameObjec.","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/Pong2D/staticFrameSyncBehaviour/#which-gameobjects-should-have-a-staticframesyncbehaviour","text":"You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position is networked, so we should add StaticFrameSyncBehaviour to them. For the Ball, its position is updated by physics and is networked. so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their states do not change so we do not need to add StaticFrameSyncBehaviour to them.","title":"Which GameObjects should have a StaticFrameSyncBehaviour?"},{"location":"tutorial/Pong2D/staticFrameSyncBehaviour/#adding-the-staticframesyncbehaviour-component","text":"Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour .","title":"Adding the StaticFrameSyncBehaviour component"},{"location":"tutorial/Pong2D/staticFrameSyncBehaviour/#staticframesyncbehaviour-owner","text":"Select the left paddle and set its Frame Sync Owner to player1 . Select the right paddle and set its Frame Sync Owner to player2 . Select the ball and set its Frame Sync Owner to computer .","title":"StaticFrameSyncBehaviour Owner"},{"location":"tutorial/Soccer/cameraFollow/","text":"Camera \u00b6 Currently, the camera does not follow the car when the car moves. In this section, we will create a simple script to make the camera follows the car. Create a new script SoccerCameraFollow in the Soccer folder. Attach the SoccerCameraFollow script to the Main Camera . Replace the contents of the script with the following: C# using SocketWeaver.FPhysics3D ; using UnityEngine ; namespace SWExample.Soccer { public float distance = 7f ; public float height = 2f ; public float rotationDamping = 2.0f ; public Transform _car ; public class SoccerCameraFollow : MonoBehaviour { void LateUpdate () { if ( _car != null ) { Quaternion newRotation = Quaternion . Slerp ( transform . rotation , _car . rotation , rotationDamping * Time . deltaTime ); Vector3 newPosition = _car . position - newRotation * Vector3 . forward * distance ; newPosition . y = _car . position . y + height ; transform . position = newPosition ; transform . LookAt ( _car ); } } } }","title":"Camera"},{"location":"tutorial/Soccer/cameraFollow/#camera","text":"Currently, the camera does not follow the car when the car moves. In this section, we will create a simple script to make the camera follows the car. Create a new script SoccerCameraFollow in the Soccer folder. Attach the SoccerCameraFollow script to the Main Camera . Replace the contents of the script with the following: C# using SocketWeaver.FPhysics3D ; using UnityEngine ; namespace SWExample.Soccer { public float distance = 7f ; public float height = 2f ; public float rotationDamping = 2.0f ; public Transform _car ; public class SoccerCameraFollow : MonoBehaviour { void LateUpdate () { if ( _car != null ) { Quaternion newRotation = Quaternion . Slerp ( transform . rotation , _car . rotation , rotationDamping * Time . deltaTime ); Vector3 newPosition = _car . position - newRotation * Vector3 . forward * distance ; newPosition . y = _car . position . y + height ; transform . position = newPosition ; transform . LookAt ( _car ); } } } }","title":"Camera"},{"location":"tutorial/Soccer/cameraTargetSelector/","text":"Camera Target Selector \u00b6 In this section, you will create a camera target selector that selects the local player as the target of the SoccerCameraFollow component. Add a StaticFrameSyncBehaviour component to the Main Camera . Set the Frame Sync Owner of the StaticFrameSyncBehaviour to Computer . Create a new script and name it CameraTargetSelector . Replace the contents of the file with the following: C# using SocketWeaver.FixedMath ; using SocketWeaver.FrameSync ; using UnityEngine ; namespace SWExample.Soccer { public class CameraTargetSelector : MonoBehaviour , IFrameSyncComputerUpdate { public FTransform player1 ; public FTransform player2 ; public SoccerCameraFollow cameraFollow ; public bool offline = false ; public void OnComputerUpdate ( FrameSyncGame game ) { if ( offline ) { cameraFollow . SetTarget ( player1 . transform ); } if ( game . localPlayer == null ) { return ; } if ( game . localPlayer . playerId == 1 ) { cameraFollow . SetTarget ( player1 . transform ); } else { cameraFollow . SetTarget ( player2 . transform ); } } } } Drag the SoccerCameraFollow to Camera Follow field of the CameraTargetSelector .","title":"Camera Target Selector"},{"location":"tutorial/Soccer/cameraTargetSelector/#camera-target-selector","text":"In this section, you will create a camera target selector that selects the local player as the target of the SoccerCameraFollow component. Add a StaticFrameSyncBehaviour component to the Main Camera . Set the Frame Sync Owner of the StaticFrameSyncBehaviour to Computer . Create a new script and name it CameraTargetSelector . Replace the contents of the file with the following: C# using SocketWeaver.FixedMath ; using SocketWeaver.FrameSync ; using UnityEngine ; namespace SWExample.Soccer { public class CameraTargetSelector : MonoBehaviour , IFrameSyncComputerUpdate { public FTransform player1 ; public FTransform player2 ; public SoccerCameraFollow cameraFollow ; public bool offline = false ; public void OnComputerUpdate ( FrameSyncGame game ) { if ( offline ) { cameraFollow . SetTarget ( player1 . transform ); } if ( game . localPlayer == null ) { return ; } if ( game . localPlayer . playerId == 1 ) { cameraFollow . SetTarget ( player1 . transform ); } else { cameraFollow . SetTarget ( player2 . transform ); } } } } Drag the SoccerCameraFollow to Camera Follow field of the CameraTargetSelector .","title":"Camera Target Selector"},{"location":"tutorial/Soccer/carController/","text":"Call Controller \u00b6 The VehicleController script that attached to the Car uses the MonoBehaviour Update() to read player inputs and uses FixedUpdate() to simulate the vehicle physics. In this section, you will create a vehicle controller script that reads networked inputs and simulate the vehicle physics in a frame simulation update. Create a new script called SoccerVehicleController and attach it to the Car . Remove the existing VehicleController script. Add a StaticFrameSyncBehaviour compoennt to the Car and set Own to Player1 . Replace the contents in the SoccerVehicleController file with the following. C# using UnityEngine ; using SocketWeaver.FrameSync ; namespace SWExample.Soccer { //implements the IFrameSyncOnStart interface to get initialized by the FrameSyncEngine. //implements the IFrameSyncPlayerUpdate interface to get updated in a frame simulation. public class SoccerVehicleController : MonoBehaviour , IFrameSyncOnStart , IFrameSyncPlayerUpdate { ArcadeCar car ; CarInputData inputData ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { car = GetComponent < ArcadeCar >(); } public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game ) { //read networked inputs inputData . steeringInput . y = player . GetInputY (); inputData . steeringInput . x = player . GetInputX (); car . inputData = inputData ; //simulate car physics car . Simulate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"Car Controller"},{"location":"tutorial/Soccer/carController/#call-controller","text":"The VehicleController script that attached to the Car uses the MonoBehaviour Update() to read player inputs and uses FixedUpdate() to simulate the vehicle physics. In this section, you will create a vehicle controller script that reads networked inputs and simulate the vehicle physics in a frame simulation update. Create a new script called SoccerVehicleController and attach it to the Car . Remove the existing VehicleController script. Add a StaticFrameSyncBehaviour compoennt to the Car and set Own to Player1 . Replace the contents in the SoccerVehicleController file with the following. C# using UnityEngine ; using SocketWeaver.FrameSync ; namespace SWExample.Soccer { //implements the IFrameSyncOnStart interface to get initialized by the FrameSyncEngine. //implements the IFrameSyncPlayerUpdate interface to get updated in a frame simulation. public class SoccerVehicleController : MonoBehaviour , IFrameSyncOnStart , IFrameSyncPlayerUpdate { ArcadeCar car ; CarInputData inputData ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { car = GetComponent < ArcadeCar >(); } public void OnPlayerUpdate ( FrameSyncPlayer player , FrameSyncGame game ) { //read networked inputs inputData . steeringInput . y = player . GetInputY (); inputData . steeringInput . x = player . GetInputX (); car . inputData = inputData ; //simulate car physics car . Simulate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"Call Controller"},{"location":"tutorial/Soccer/desync/","text":"Desync Detection \u00b6 Currently, the game does not verify clients simulation results. So if the clients simulation diverged, their simulation would only get further apart from the frame the desync started. The FrameSyncEngine hashes the FrameSyncBehaviour data once every 60 FrameSync frames. The FrameSync server will verify the clients checksums and notify the clients which have different simulation results from others. In this game, the only stateful component managed by the FrameSyncBehaviour is the SoccerGameFlow component. You have implemented the IFrameSyncDataContainer interface to export its states so the player scores and timerId are being verified. You also created the SoccerPhysicsSnapshot to take snapshots of the physics engine. To verify the physics states stay in sync, you can override the OnFrameSyncGetExternalChecksum() method in the SoccerFrameSyncEngineController . Add the highlighted code to the SoccerFrameSyncEngineController . You are going to verify the positions of the Ball and the Cars using the FrameSyncChecksum API. Also, you are going to stop the FrameSyncEngine on desync. Drag the ball and the cars to the checksum fields in the inspector. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; [Header(\"checksum\")] public FTransform ball ; public FTransform player1 ; public FTransform player2 ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } protected override IFrameSyncSnapshot OnFrameSyncCreateCustomSnapshot ( int frameNumber ) { return new PhysicsSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomSnapshot ( int frameNumber , byte [] bytes ) { return new PhysicsSnapshot ( frameNumber , bytes ); } protected override uint OnFrameSyncGetCustomHashCode () { using ( FrameSyncChecksum checksum = FrameSyncChecksum . Instance ) { //If velocities are out of sync, //Positions should be out of sync as well. //So we are only verifying positions. checksum . Add ( ball . position ); checksum . Add ( player1 . position ); checksum . Add ( player2 . position ); return checksum . value ; } } protected override FrameSyncRestoreMethod OnFrameSyncDesyncDetected ( FrameSyncDesyncInfo desyncInfo ) { Debug . LogError ( \"Desync!\" ); return FrameSyncRestoreMethod . Abort ; } } }","title":"Desync Detection"},{"location":"tutorial/Soccer/desync/#desync-detection","text":"Currently, the game does not verify clients simulation results. So if the clients simulation diverged, their simulation would only get further apart from the frame the desync started. The FrameSyncEngine hashes the FrameSyncBehaviour data once every 60 FrameSync frames. The FrameSync server will verify the clients checksums and notify the clients which have different simulation results from others. In this game, the only stateful component managed by the FrameSyncBehaviour is the SoccerGameFlow component. You have implemented the IFrameSyncDataContainer interface to export its states so the player scores and timerId are being verified. You also created the SoccerPhysicsSnapshot to take snapshots of the physics engine. To verify the physics states stay in sync, you can override the OnFrameSyncGetExternalChecksum() method in the SoccerFrameSyncEngineController . Add the highlighted code to the SoccerFrameSyncEngineController . You are going to verify the positions of the Ball and the Cars using the FrameSyncChecksum API. Also, you are going to stop the FrameSyncEngine on desync. Drag the ball and the cars to the checksum fields in the inspector. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; [Header(\"checksum\")] public FTransform ball ; public FTransform player1 ; public FTransform player2 ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } protected override IFrameSyncSnapshot OnFrameSyncCreateCustomSnapshot ( int frameNumber ) { return new PhysicsSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomSnapshot ( int frameNumber , byte [] bytes ) { return new PhysicsSnapshot ( frameNumber , bytes ); } protected override uint OnFrameSyncGetCustomHashCode () { using ( FrameSyncChecksum checksum = FrameSyncChecksum . Instance ) { //If velocities are out of sync, //Positions should be out of sync as well. //So we are only verifying positions. checksum . Add ( ball . position ); checksum . Add ( player1 . position ); checksum . Add ( player2 . position ); return checksum . value ; } } protected override FrameSyncRestoreMethod OnFrameSyncDesyncDetected ( FrameSyncDesyncInfo desyncInfo ) { Debug . LogError ( \"Desync!\" ); return FrameSyncRestoreMethod . Abort ; } } }","title":"Desync Detection"},{"location":"tutorial/Soccer/displayScore/","text":"Display The Scores \u00b6 In this section, you will update the HUD to display the scores. Add a StaticFrameSyncBehaviour to the GameFlow GameObject. We want to access the FrameSyncGame in the SoccerGameFlow script to get the time elapsed since the game started. Set the Owner of the StaticFrameSyncBehaviour to computer because the GameFlow is not owned by any player. Add the highlighted lines to the SoccerGameFlow script. Drag the Time , Player1 , and Player2 text to the SoccerGameFlow inspector. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } } } } Test \u00b6 Hit Play , you should see the time text and the score texts are updated corretly.","title":"Display Score"},{"location":"tutorial/Soccer/displayScore/#display-the-scores","text":"In this section, you will update the HUD to display the scores. Add a StaticFrameSyncBehaviour to the GameFlow GameObject. We want to access the FrameSyncGame in the SoccerGameFlow script to get the time elapsed since the game started. Set the Owner of the StaticFrameSyncBehaviour to computer because the GameFlow is not owned by any player. Add the highlighted lines to the SoccerGameFlow script. Drag the Time , Player1 , and Player2 text to the SoccerGameFlow inspector. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } } } }","title":"Display The Scores"},{"location":"tutorial/Soccer/displayScore/#test","text":"Hit Play , you should see the time text and the score texts are updated corretly.","title":"Test"},{"location":"tutorial/Soccer/frameSyncEngineController/","text":"FrameSyncEngineController \u00b6 In this section, you will create a subclass of the built-in FrameSyncEngineController to control the FrameSyncEninge. Create a new script and name it SoccerFrameSyncEngineController . Create a new empty GameObject and attach the SoccerFrameSyncEngineController to it. In the SoccerFrameSyncEngineController script, replace its contents with the following. Drag the FPhysics3DManager into the physicsEngine field in the inspector. Drag the InputSettings asset into the Input Settings field. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"FrameSyncEngineController"},{"location":"tutorial/Soccer/frameSyncEngineController/#framesyncenginecontroller","text":"In this section, you will create a subclass of the built-in FrameSyncEngineController to control the FrameSyncEninge. Create a new script and name it SoccerFrameSyncEngineController . Create a new empty GameObject and attach the SoccerFrameSyncEngineController to it. In the SoccerFrameSyncEngineController script, replace its contents with the following. Drag the FPhysics3DManager into the physicsEngine field in the inspector. Drag the InputSettings asset into the Input Settings field. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } } }","title":"FrameSyncEngineController"},{"location":"tutorial/Soccer/frameSyncTimer/","text":"FrameSyncTimer \u00b6 In this section, you will use FrameSyncTimer to add a delay before resetting the Ball and the Car s positions. Update/Add the highlighted lines to the SoccerGameFlow script. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } } } Test \u00b6","title":"FrameSyncTimer"},{"location":"tutorial/Soccer/frameSyncTimer/#framesynctimer","text":"In this section, you will use FrameSyncTimer to add a delay before resetting the Ball and the Car s positions. Update/Add the highlighted lines to the SoccerGameFlow script. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } } }","title":"FrameSyncTimer"},{"location":"tutorial/Soccer/frameSyncTimer/#test","text":"","title":"Test"},{"location":"tutorial/Soccer/gameFlow/","text":"Game Flow \u00b6 Next, you'll implment the game flow logic. Add a new Empty GameObject and name it GameFlow Add a new script called SoccerGameFlow to the GameFlow GameObject. Replace the contents of the file with the following. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour { [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } } } }","title":"Game Flow"},{"location":"tutorial/Soccer/gameFlow/#game-flow","text":"Next, you'll implment the game flow logic. Add a new Empty GameObject and name it GameFlow Add a new script called SoccerGameFlow to the GameFlow GameObject. Replace the contents of the file with the following. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour { [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } } } }","title":"Game Flow"},{"location":"tutorial/Soccer/gameFlowSnapshot/","text":"Game Flow Snapshot \u00b6 In this section, you will implement the IFrameSyncDataContainer interface to export/import the data stored in the SoccerGameFlow component. Update/Add the highlighted lines to the SoccerGameFlow script. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); } } }","title":"Game Flow Snapshot"},{"location":"tutorial/Soccer/gameFlowSnapshot/#game-flow-snapshot","text":"In this section, you will implement the IFrameSyncDataContainer interface to export/import the data stored in the SoccerGameFlow component. Update/Add the highlighted lines to the SoccerGameFlow script. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); } } }","title":"Game Flow Snapshot"},{"location":"tutorial/Soccer/getStarted/","text":"Get Started \u00b6 To get started, in the Project window, create a new folder under the Assets folder and name it Soccer . All the assets used in this game will be created inside of this folder to make them easy to find. After that, create a new scene in the Soccer folder and name it SoccerGame .","title":"Get Started"},{"location":"tutorial/Soccer/getStarted/#get-started","text":"To get started, in the Project window, create a new folder under the Assets folder and name it Soccer . All the assets used in this game will be created inside of this folder to make them easy to find. After that, create a new scene in the Soccer folder and name it SoccerGame .","title":"Get Started"},{"location":"tutorial/Soccer/goal/","text":"Goal \u00b6 In this section, you will implement the soccer goal logic. Create a new script SoccerGoal and add it to the Goal GameObject. Add a StaticFrameSyncBehaviour component to the Goal and set its Own to Player1 . Replace the contents in the SoccerGoal script with the following. C# using SocketWeaver.FPhysics3D ; using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Soccer { public class SoccerGoal : MonoBehaviour , IFrameSyncOnStart { FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; } public void OnFTriggerEnter ( FCollider3D fCollider ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; Debug . Log ( $ \"{fCollider.name} trigger enter, updateType={updateType} frameNumber={frameNumber}\" ); //score FrameSyncPlayer player = _frameSyncBehaviour . owner ; SoccerGameFlow gameFlow = FindObjectOfType < SoccerGameFlow >(); gameFlow . PlayerScored ( player ); } } } Trigger events \u00b6 To receive the trigger events of the Goal collider: Enabled Events of the FRigidbody3D component of the Goal GameObject Add an event listener to the OnTriggerEnter event, and select OnFTriggerEnter . Physics Layer Collision Matrix \u00b6 FPhysics supports the Unity physics layer collision matrix. You will create layers and change their collision matrix so the Goal collider only collides with the Ball . Create the following layers and assign the Car , the Ball and the Goal to their layers Layer Name GameObject Description SoccerBall Ball Collides with the cars, the goals, and the Arena SocerCars Cars Collides with other cars, the ball, and the Arena SoccerGoal Goals Collides with the ball only Select Edit->Project Settings->Physics . Update the Layer Collision Matrix to the following:","title":"Goal"},{"location":"tutorial/Soccer/goal/#goal","text":"In this section, you will implement the soccer goal logic. Create a new script SoccerGoal and add it to the Goal GameObject. Add a StaticFrameSyncBehaviour component to the Goal and set its Own to Player1 . Replace the contents in the SoccerGoal script with the following. C# using SocketWeaver.FPhysics3D ; using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Soccer { public class SoccerGoal : MonoBehaviour , IFrameSyncOnStart { FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; } public void OnFTriggerEnter ( FCollider3D fCollider ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; Debug . Log ( $ \"{fCollider.name} trigger enter, updateType={updateType} frameNumber={frameNumber}\" ); //score FrameSyncPlayer player = _frameSyncBehaviour . owner ; SoccerGameFlow gameFlow = FindObjectOfType < SoccerGameFlow >(); gameFlow . PlayerScored ( player ); } } }","title":"Goal"},{"location":"tutorial/Soccer/goal/#trigger-events","text":"To receive the trigger events of the Goal collider: Enabled Events of the FRigidbody3D component of the Goal GameObject Add an event listener to the OnTriggerEnter event, and select OnFTriggerEnter .","title":"Trigger events"},{"location":"tutorial/Soccer/goal/#physics-layer-collision-matrix","text":"FPhysics supports the Unity physics layer collision matrix. You will create layers and change their collision matrix so the Goal collider only collides with the Ball . Create the following layers and assign the Car , the Ball and the Goal to their layers Layer Name GameObject Description SoccerBall Ball Collides with the cars, the goals, and the Arena SocerCars Cars Collides with other cars, the ball, and the Arena SoccerGoal Goals Collides with the ball only Select Edit->Project Settings->Physics . Update the Layer Collision Matrix to the following:","title":"Physics Layer Collision Matrix"},{"location":"tutorial/Soccer/goalExplosion/","text":"Goal Explosion \u00b6 In this secion, you are going to add a goal explosion visual effect when player scores. Explosion Force \u00b6 If you play the game in the Online Rollback mode, when the player scores you will see a few player scored messages. These logs are generated because the player scored in the prediction updates. The game is still deterministic because the scores always get restored to the value before a normal update. We can improve this by only allowing the players to score in a normal update. Update/Add the highlighted lines to the SoccerGoal script. C# using SocketWeaver.FPhysics3D ; using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Soccer { public class SoccerGoal : MonoBehaviour , IFrameSyncOnStart { FrameSyncBehaviour _frameSyncBehaviour ; FTransform _fTransform ; [Header(\"Explosion\")] public FFloat range = FFloat . FromDivision ( 30 , 1 ); public FCollider3D [] colliders = new FCollider3D [ 2 ]; public LayerMask playerMask ; public FVector3 forceDirection ; public FFloat strenge ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; _fTransform = GetComponent < FTransform >(); } public void OnFTriggerEnter ( FCollider3D fCollider ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; Debug . Log ( $ \"{fCollider.name} trigger enter, updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { //score FrameSyncPlayer player = _frameSyncBehaviour . owner ; SoccerGameFlow gameFlow = FindObjectOfType < SoccerGameFlow >(); gameFlow . PlayerScored ( player ); //find nearby players int collidersCount = FPhysics3D . OverlapSphere ( _fTransform . position , range , playerMask , colliders ); //apply force for ( int i = 0 ; i < collidersCount ; i ++) { FCollider3D collider = colliders [ i ]; collider . attachedBody . AddForce ( forceDirection . normalized * strenge , ForceMode . VelocityChange ); } } } } } Select the SoccerGoal component. Set Player Mask to SoccerPlayer . Set Force Directiont to (1, 0.3, 0) for player1's goal. Set Force Directiont to (-1, 0.3, 0) for player2's goal. Set Strengh to 50. Select the Arcade Car component of the Cars and disable Speed Limit . Explosion Particle Effect \u00b6 Update/Add the highlighted lines to the SoccerGameFlow script. You will instantiate a particle effect and disable the ball when the players score. When resetting the game, you will re-enable the ball. Drag the SoccerExplosion prefab to the SoccerGameFlow inspector. The active state of the ball is a game state that affects the simulation result. The FrameSyncEngine snapshots the active state of FrameSyncBehaviour GameObject automatically. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; [Header(\"VFX\")] public GameObject scoreEffect ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); ball . gameObject . SetActive ( false ); Instantiate ( scoreEffect , ball . transform . position , ball . transform . rotation ); } void ResetGame () { ball . gameObject . SetActive ( true ); ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); } } } Reset Transition \u00b6 Update/Add the highlighted lines to the SoccerGameFlow script. Create 2 more FrameSyncTimers for the fade-in and fade-out effects. Check the UpdateType of the FrameSyncGame. The visual effects should only run in a normal update. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; public Image fade ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public FFloat fadeTime = FFloat . FromDivision ( 2 , 1 ); public int resetTimer ; public int fadeInTimer ; public int fadeOutTimer ; [Header(\"VFX\")] public GameObject scoreEffect ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); fadeInTimer = FrameSyncTimer . CreateTimer ( fadeTime , false ); fadeOutTimer = FrameSyncTimer . CreateTimer ( fadeTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { FrameSyncTimer . RestartTimer ( fadeInTimer ); } } if ( timerId == fadeInTimer ) { Debug . Log ( $ \"fadeInTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { CrossFade ( 1 , 1 ); FrameSyncTimer . RestartTimer ( fadeOutTimer ); } } if ( timerId == fadeOutTimer ) { Debug . Log ( $ \"fadeOutTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { ResetGame (); CrossFade ( 0 , 1 ); } } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); if ( FrameSyncTimer . IsInvoking ( resetTimer )) { Debug . Log ( \"Game resetting ignored\" ); return ; } //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); ball . gameObject . SetActive ( false ); Instantiate ( scoreEffect , ball . transform . position , ball . transform . rotation ); } void CrossFade ( float alpha , float duration ) { Color fixedColor = fade . color ; fixedColor . a = 1 ; fade . color = fixedColor ; fade . CrossFadeAlpha ( 0f , 0f , true ); fade . CrossFadeAlpha ( alpha , duration , false ); } void ResetGame () { ball . gameObject . SetActive ( true ); ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); fadeInTimer = buffer . PopInt (); fadeOutTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); buffer . Push ( fadeInTimer ); buffer . Push ( fadeOutTimer ); } } } Create a UI Panel under the Canvas and name it Fade . Set its source image to None. Set its color to Black and alpha to 0. Drag the Fade panel to the SoccerGameFlow component in the inspector.","title":"Goal Explosion"},{"location":"tutorial/Soccer/goalExplosion/#goal-explosion","text":"In this secion, you are going to add a goal explosion visual effect when player scores.","title":"Goal Explosion"},{"location":"tutorial/Soccer/goalExplosion/#explosion-force","text":"If you play the game in the Online Rollback mode, when the player scores you will see a few player scored messages. These logs are generated because the player scored in the prediction updates. The game is still deterministic because the scores always get restored to the value before a normal update. We can improve this by only allowing the players to score in a normal update. Update/Add the highlighted lines to the SoccerGoal script. C# using SocketWeaver.FPhysics3D ; using UnityEngine ; using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; namespace SWExample.Soccer { public class SoccerGoal : MonoBehaviour , IFrameSyncOnStart { FrameSyncBehaviour _frameSyncBehaviour ; FTransform _fTransform ; [Header(\"Explosion\")] public FFloat range = FFloat . FromDivision ( 30 , 1 ); public FCollider3D [] colliders = new FCollider3D [ 2 ]; public LayerMask playerMask ; public FVector3 forceDirection ; public FFloat strenge ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; _fTransform = GetComponent < FTransform >(); } public void OnFTriggerEnter ( FCollider3D fCollider ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; Debug . Log ( $ \"{fCollider.name} trigger enter, updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { //score FrameSyncPlayer player = _frameSyncBehaviour . owner ; SoccerGameFlow gameFlow = FindObjectOfType < SoccerGameFlow >(); gameFlow . PlayerScored ( player ); //find nearby players int collidersCount = FPhysics3D . OverlapSphere ( _fTransform . position , range , playerMask , colliders ); //apply force for ( int i = 0 ; i < collidersCount ; i ++) { FCollider3D collider = colliders [ i ]; collider . attachedBody . AddForce ( forceDirection . normalized * strenge , ForceMode . VelocityChange ); } } } } } Select the SoccerGoal component. Set Player Mask to SoccerPlayer . Set Force Directiont to (1, 0.3, 0) for player1's goal. Set Force Directiont to (-1, 0.3, 0) for player2's goal. Set Strengh to 50. Select the Arcade Car component of the Cars and disable Speed Limit .","title":"Explosion Force"},{"location":"tutorial/Soccer/goalExplosion/#explosion-particle-effect","text":"Update/Add the highlighted lines to the SoccerGameFlow script. You will instantiate a particle effect and disable the ball when the players score. When resetting the game, you will re-enable the ball. Drag the SoccerExplosion prefab to the SoccerGameFlow inspector. The active state of the ball is a game state that affects the simulation result. The FrameSyncEngine snapshots the active state of FrameSyncBehaviour GameObject automatically. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public int resetTimer ; [Header(\"VFX\")] public GameObject scoreEffect ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); ResetGame (); } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); ball . gameObject . SetActive ( false ); Instantiate ( scoreEffect , ball . transform . position , ball . transform . rotation ); } void ResetGame () { ball . gameObject . SetActive ( true ); ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); } } }","title":"Explosion Particle Effect"},{"location":"tutorial/Soccer/goalExplosion/#reset-transition","text":"Update/Add the highlighted lines to the SoccerGameFlow script. Create 2 more FrameSyncTimers for the fade-in and fade-out effects. Check the UpdateType of the FrameSyncGame. The visual effects should only run in a normal update. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncTimerEventHandler , IFrameSyncOnStart , IFrameSyncComputerUpdate , IFrameSyncDataContainer { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; public Image fade ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; [Header(\"Timer\")] public FFloat resetGameTime = FFloat . FromDivision ( 5 , 1 ); public FFloat fadeTime = FFloat . FromDivision ( 2 , 1 ); public int resetTimer ; public int fadeInTimer ; public int fadeOutTimer ; [Header(\"VFX\")] public GameObject scoreEffect ; FrameSyncBehaviour _frameSyncBehaviour ; public void OnStart ( FrameSyncBehaviour frameSyncBehaviour ) { _frameSyncBehaviour = frameSyncBehaviour ; resetTimer = FrameSyncTimer . CreateTimer ( resetGameTime , false ); fadeInTimer = FrameSyncTimer . CreateTimer ( fadeTime , false ); fadeOutTimer = FrameSyncTimer . CreateTimer ( fadeTime , false ); } public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void OnTimerEvent ( int timerId , FFloat elapsed ) { FrameSyncUpdateType updateType = _frameSyncBehaviour . game . updateType ; int frameNumber = _frameSyncBehaviour . game . frameNumber ; if ( timerId == resetTimer ) { Debug . Log ( $ \"ResetTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { FrameSyncTimer . RestartTimer ( fadeInTimer ); } } if ( timerId == fadeInTimer ) { Debug . Log ( $ \"fadeInTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { CrossFade ( 1 , 1 ); FrameSyncTimer . RestartTimer ( fadeOutTimer ); } } if ( timerId == fadeOutTimer ) { Debug . Log ( $ \"fadeOutTimer updateType={updateType} frameNumber={frameNumber}\" ); if ( updateType == FrameSyncUpdateType . Normal ) { ResetGame (); CrossFade ( 0 , 1 ); } } } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); if ( FrameSyncTimer . IsInvoking ( resetTimer )) { Debug . Log ( \"Game resetting ignored\" ); return ; } //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } FrameSyncTimer . RestartTimer ( resetTimer ); ball . gameObject . SetActive ( false ); Instantiate ( scoreEffect , ball . transform . position , ball . transform . rotation ); } void CrossFade ( float alpha , float duration ) { Color fixedColor = fade . color ; fixedColor . a = 1 ; fade . color = fixedColor ; fade . CrossFadeAlpha ( 0f , 0f , true ); fade . CrossFadeAlpha ( alpha , duration , false ); } void ResetGame () { ball . gameObject . SetActive ( true ); ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } public void OnImport ( SWBytes buffer ) { player1Score = buffer . PopInt (); player2Score = buffer . PopInt (); resetTimer = buffer . PopInt (); fadeInTimer = buffer . PopInt (); fadeOutTimer = buffer . PopInt (); } public void OnExport ( SWBytes buffer ) { buffer . Push ( player1Score ); buffer . Push ( player2Score ); buffer . Push ( resetTimer ); buffer . Push ( fadeInTimer ); buffer . Push ( fadeOutTimer ); } } } Create a UI Panel under the Canvas and name it Fade . Set its source image to None. Set its color to Black and alpha to 0. Drag the Fade panel to the SoccerGameFlow component in the inspector.","title":"Reset Transition"},{"location":"tutorial/Soccer/hud/","text":"HUD \u00b6 In this section, you will add a HUD to show the scores of the players. Background \u00b6 Add a UI Panel and name it Background . Set its RectTransform Anchor Preset to Stretch Top. Set RectTransform left: 0 , Right: 0 , Height: 200 , Ros Y: -100 , Pos Z: 0 Remove its source image, and set color alpha to 0. Time \u00b6 Add a child UI Panel under Background and name it Time Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 150 , Height: 75 , Pos X: 0 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to black and alpha to 0.5. Add a Text under Time Panel and name it Time . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 150 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white. Player1 Score \u00b6 Add a child UI Panel under Background and name it Player1 Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: -115 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to blue and alpha to 0.75. Add a Text under Player1 Panel and name it Player1 . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white. Player2 Score \u00b6 Add a child UI Panel under Background and name it Player2 Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 115 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to red and alpha to 0.74. Add a Text under Player2 Panel and name it Player2 . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white. The Hierarchy should look like The Scene should look like","title":"HUD"},{"location":"tutorial/Soccer/hud/#hud","text":"In this section, you will add a HUD to show the scores of the players.","title":"HUD"},{"location":"tutorial/Soccer/hud/#background","text":"Add a UI Panel and name it Background . Set its RectTransform Anchor Preset to Stretch Top. Set RectTransform left: 0 , Right: 0 , Height: 200 , Ros Y: -100 , Pos Z: 0 Remove its source image, and set color alpha to 0.","title":"Background"},{"location":"tutorial/Soccer/hud/#time","text":"Add a child UI Panel under Background and name it Time Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 150 , Height: 75 , Pos X: 0 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to black and alpha to 0.5. Add a Text under Time Panel and name it Time . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 150 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white.","title":"Time"},{"location":"tutorial/Soccer/hud/#player1-score","text":"Add a child UI Panel under Background and name it Player1 Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: -115 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to blue and alpha to 0.75. Add a Text under Player1 Panel and name it Player1 . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white.","title":"Player1 Score"},{"location":"tutorial/Soccer/hud/#player2-score","text":"Add a child UI Panel under Background and name it Player2 Panel . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 115 , Pos Y: 50 , Pos Z: 0 Remove its source image, and set color to red and alpha to 0.74. Add a Text under Player2 Panel and name it Player2 . Set its RectTransform Anchor Preset to Center Middle . Set RectTransform Width: 75 , Height: 75 , Pos X: 0 , Pos Y: 0 , Pos Z: 0 Set Font size to 40. Set Text Alignment to horizontal center, and vertical center. Set Text color to white. The Hierarchy should look like The Scene should look like","title":"Player2 Score"},{"location":"tutorial/Soccer/inputSettings/","text":"Declare Inputs for Your Game \u00b6 In this section, you will create an InputSettings scriptableObject for your game. Creating an InputSettings ScriptableObject \u00b6 Right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings . Name the new asset FrameSyncInputSettings . Adding Inputs \u00b6 In this game, the player uses the WASD to drive the car. Select the FrameSyncInputSettings and configure it as shown below. Make sure that Name Space is set to SWExample.Soccer which is the c# namespace of this game. Click the Save button.","title":"Declare Inputs for Your Game"},{"location":"tutorial/Soccer/inputSettings/#declare-inputs-for-your-game","text":"In this section, you will create an InputSettings scriptableObject for your game.","title":"Declare Inputs for Your Game"},{"location":"tutorial/Soccer/inputSettings/#creating-an-inputsettings-scriptableobject","text":"Right click in the project browser, and select Create->SocketWeaver->FrameSync->InputSettings . Name the new asset FrameSyncInputSettings .","title":"Creating an InputSettings ScriptableObject"},{"location":"tutorial/Soccer/inputSettings/#adding-inputs","text":"In this game, the player uses the WASD to drive the car. Select the FrameSyncInputSettings and configure it as shown below. Make sure that Name Space is set to SWExample.Soccer which is the c# namespace of this game. Click the Save button.","title":"Adding Inputs"},{"location":"tutorial/Soccer/overview/","text":"Soccer \u00b6 Soccer is a Rocket League like 3D vehicular soccer game. It is deisgned to demonstrate the predition/rollback simulation feature of the FrameSync Library. The tutorials should take less than 60 mintues to complete. In these step-by-step tutorials, you will: Use the FPhysics3D engine Create a custom script to control a arcade-style raycast car. Create snapshots of the FPhysics3D worlds to restore the physics states of the Rigidbodies. Use FrameSync Recorder and FrameSync debugger to detect and fix desyncs errors.","title":"Overview"},{"location":"tutorial/Soccer/overview/#soccer","text":"Soccer is a Rocket League like 3D vehicular soccer game. It is deisgned to demonstrate the predition/rollback simulation feature of the FrameSync Library. The tutorials should take less than 60 mintues to complete. In these step-by-step tutorials, you will: Use the FPhysics3D engine Create a custom script to control a arcade-style raycast car. Create snapshots of the FPhysics3D worlds to restore the physics states of the Rigidbodies. Use FrameSync Recorder and FrameSync debugger to detect and fix desyncs errors.","title":"Soccer"},{"location":"tutorial/Soccer/physicsEngineSnapshot/","text":"Physics Engine Snapshot \u00b6 You will use the following methods to create snapshot of the physics engine. Name Description FPhysics3D.Snapshot Create a snapshot of the physics engine FPhysics3D.ImportSnapshot Create a snapshot using the given byte data You will use the following method to restore the physics engine to a snapshot. Name Description FPhysics3D.Restore Restore the physics engine to a snapshot You will use the following method to export the data of a snapshot in the byte array format. Name Description FPhysics3D.ExportSnapshot Export the data of a snapshot in byte array format. SoccerPhysics3DSnapshot \u00b6 Create a new c# script and call it SoccerPhysics3DSnapshot . Replace the content of the file with the following. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; public class SoccerPhysics3DSnapshot : IFrameSyncSnapshot { FSnapshot3D snapshot ; public int frameNumber { get ; } public SoccerPhysics3DSnapshot ( int frameNumber ) { snapshot = FPhysics3D . Snapshot (); this . frameNumber = frameNumber ; } public SoccerPhysics3DSnapshot ( int frameNumber , byte [] bytes ) { snapshot = FPhysics3D . ImportSnapshot ( bytes , bytes . Length ); this . frameNumber = frameNumber ; } //==========IFrameSyncSnapshot========== public void Clear () { if ( snapshot != null ) { FPhysics3D . DestroySnapshot ( snapshot ); snapshot = null ; } } public SWBytes Export () { byte [] bytes = new byte [ 1014 ]; int size = FPhysics3D . ExportSnapshot ( snapshot , bytes , 1024 ); SWBytes b = new SWBytes ( size ); b . Push ( bytes , size ); return b ; } public void Restore () { FPhysics3D . Restore ( snapshot ); } } Add the highlighted code to the SoccerFrameSyncEngineController . You are going to create snapshots of the physics engine when the FrameSyncEngine wants to create/import custom snapshots. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } protected override IFrameSyncSnapshot OnFrameSyncCreateCustomSnapshot ( int frameNumber ) { return new SoccerPhysics3DSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomSnapshot ( int frameNumber , byte [] bytes ) { return new SoccerPhysics3DSnapshot ( frameNumber , bytes ); } } }","title":"Phyiscs Engine Snapshot"},{"location":"tutorial/Soccer/physicsEngineSnapshot/#physics-engine-snapshot","text":"You will use the following methods to create snapshot of the physics engine. Name Description FPhysics3D.Snapshot Create a snapshot of the physics engine FPhysics3D.ImportSnapshot Create a snapshot using the given byte data You will use the following method to restore the physics engine to a snapshot. Name Description FPhysics3D.Restore Restore the physics engine to a snapshot You will use the following method to export the data of a snapshot in the byte array format. Name Description FPhysics3D.ExportSnapshot Export the data of a snapshot in byte array format.","title":"Physics Engine Snapshot"},{"location":"tutorial/Soccer/physicsEngineSnapshot/#soccerphysics3dsnapshot","text":"Create a new c# script and call it SoccerPhysics3DSnapshot . Replace the content of the file with the following. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; public class SoccerPhysics3DSnapshot : IFrameSyncSnapshot { FSnapshot3D snapshot ; public int frameNumber { get ; } public SoccerPhysics3DSnapshot ( int frameNumber ) { snapshot = FPhysics3D . Snapshot (); this . frameNumber = frameNumber ; } public SoccerPhysics3DSnapshot ( int frameNumber , byte [] bytes ) { snapshot = FPhysics3D . ImportSnapshot ( bytes , bytes . Length ); this . frameNumber = frameNumber ; } //==========IFrameSyncSnapshot========== public void Clear () { if ( snapshot != null ) { FPhysics3D . DestroySnapshot ( snapshot ); snapshot = null ; } } public SWBytes Export () { byte [] bytes = new byte [ 1014 ]; int size = FPhysics3D . ExportSnapshot ( snapshot , bytes , 1024 ); SWBytes b = new SWBytes ( size ); b . Push ( bytes , size ); return b ; } public void Restore () { FPhysics3D . Restore ( snapshot ); } } Add the highlighted code to the SoccerFrameSyncEngineController . You are going to create snapshots of the physics engine when the FrameSyncEngine wants to create/import custom snapshots. C# using SocketWeaver.FrameSync ; using SocketWeaver.FPhysics3D ; using SocketWeaver.FixedMath ; using UnityEngine ; namespace SWExample.Soccer { public class SoccerFrameSyncEngineController : FrameSyncEngineController { public FPhysics3DManager physicsEngine ; protected override void OnFrameSyncCollectPlayerInput ( FrameSyncEngine frameSyncEngine , FrameSyncGame game ) { if ( engineMode == EngineMode . Offline ) { FrameSyncPlayer player1 = game . GetPlayer ( 1 ); player1 . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); player1 . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } else { frameSyncEngine . game . localPlayer . SetInputX (( FFloat ) Input . GetAxis ( \"Horizontal\" )); frameSyncEngine . game . localPlayer . SetInputY (( FFloat ) Input . GetAxis ( \"Vertical\" )); } } protected override void OnStart () { physicsEngine . Initialize (); } protected override void OnFrameSyncFinishedSimulationForCurrentFrame ( int frameNumber ) { physicsEngine . OnUpdate ( FrameSyncTime . fixedDeltaTime ); } protected override IFrameSyncSnapshot OnFrameSyncCreateCustomSnapshot ( int frameNumber ) { return new SoccerPhysics3DSnapshot ( frameNumber ); } protected override IFrameSyncSnapshot OnFrameSyncImportCustomSnapshot ( int frameNumber , byte [] bytes ) { return new SoccerPhysics3DSnapshot ( frameNumber , bytes ); } } }","title":"SoccerPhysics3DSnapshot"},{"location":"tutorial/Soccer/playOnline/","text":"Playing Online \u00b6 Belive it or not, your game is almost ready to be played online. Let's first add a car and another goal for player2. Drag the Car to the Project window to make it a prefab. Drag the Car prefab to the scene for player2. Set the Frame Sync Own of player2's StaticFrameSyncBehaviour to Player2 . Do the same for the Goal . Move the player2 car to (65, 0.6, 50). Rotate the player2 car to (0, 90, 0). Move the player2 goal to (158.4, 6, 50). Drag the player1's car to Player 1 field of the CameraTargetSelector . Drag the player2's car to Player 2 field of the CameraTargetSelector . Info Make sure to change the Engine Mode of the SoccerFrameSyncEngineController to Online . FrameSync Demo Lobby Scene \u00b6 You will use the demo lobby scene that comes with the library to handle the matchmaking of the game. Open the Lobby scene. Select the Lobby GameObject and set Scene Name to SoccerGame Info Make sure to add the SoccerGame scene to the build settings. Launch Another Instance of The Unity Editor \u00b6 Install ParrelSync, and Select ParrelSync->Clones Manager->Add new clone , and select Open in New Editor after the clone is created. Test \u00b6 Hit Play , you can control the car using the WASD keys. When the ball hits the invisible goal, you should see message \"PlayerScored player={playerID}\" logged in the Console .","title":"Play Online"},{"location":"tutorial/Soccer/playOnline/#playing-online","text":"Belive it or not, your game is almost ready to be played online. Let's first add a car and another goal for player2. Drag the Car to the Project window to make it a prefab. Drag the Car prefab to the scene for player2. Set the Frame Sync Own of player2's StaticFrameSyncBehaviour to Player2 . Do the same for the Goal . Move the player2 car to (65, 0.6, 50). Rotate the player2 car to (0, 90, 0). Move the player2 goal to (158.4, 6, 50). Drag the player1's car to Player 1 field of the CameraTargetSelector . Drag the player2's car to Player 2 field of the CameraTargetSelector . Info Make sure to change the Engine Mode of the SoccerFrameSyncEngineController to Online .","title":"Playing Online"},{"location":"tutorial/Soccer/playOnline/#framesync-demo-lobby-scene","text":"You will use the demo lobby scene that comes with the library to handle the matchmaking of the game. Open the Lobby scene. Select the Lobby GameObject and set Scene Name to SoccerGame Info Make sure to add the SoccerGame scene to the build settings.","title":"FrameSync Demo Lobby Scene"},{"location":"tutorial/Soccer/playOnline/#launch-another-instance-of-the-unity-editor","text":"Install ParrelSync, and Select ParrelSync->Clones Manager->Add new clone , and select Open in New Editor after the clone is created.","title":"Launch Another Instance of The Unity Editor"},{"location":"tutorial/Soccer/playOnline/#test","text":"Hit Play , you can control the car using the WASD keys. When the ball hits the invisible goal, you should see message \"PlayerScored player={playerID}\" logged in the Console .","title":"Test"},{"location":"tutorial/Soccer/playOnline2/","text":"Playing Online with Predicton/Rollback Enabled \u00b6 Now the game is complete, You can change the Engine Mode of the SoccerFrameSyncEngineController to Online Rollback . Play the game again, the input delay should be gone now. Congratulations You have done the tutorial.","title":"Play in Online Rollback Mode"},{"location":"tutorial/Soccer/playOnline2/#playing-online-with-predictonrollback-enabled","text":"Now the game is complete, You can change the Engine Mode of the SoccerFrameSyncEngineController to Online Rollback . Play the game again, the input delay should be gone now. Congratulations You have done the tutorial.","title":"Playing Online with Predicton/Rollback Enabled"},{"location":"tutorial/Soccer/reset/","text":"Reset to The Start Position \u00b6 Add the highlighted lines to the SoccerGameFlow script to reset the Ball and the Car s to their starting positions. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } ResetGame (); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } } } Drag the Ball , and the Car s into the Rigidbodies fields. Create empty GameObjects at the starting positions of the Ball , and the Call s. Attach FTransform component to the empty GameObjects. Drag the empty GameObjects to the Start Positions fields. Test \u00b6 Hit Play , you should see that the balls and the cars get reset to their starting positions.","title":"Reset to Start Position"},{"location":"tutorial/Soccer/reset/#reset-to-the-start-position","text":"Add the highlighted lines to the SoccerGameFlow script to reset the Ball and the Car s to their starting positions. C# using SocketWeaver.FrameSync ; using SocketWeaver.FixedMath ; using UnityEngine ; using UnityEngine.UI ; using SocketWeaver.FPhysics3D ; using SocketWeaver.Core ; namespace SWExample.Soccer { public class SoccerGameFlow : MonoBehaviour , IFrameSyncComputerUpdate { [Header(\"UI\")] public Text timeText ; public Text player1Text ; public Text player2Text ; [Header(\"Rigidbodies\")] public FRigidbody3D ball ; public FRigidbody3D player1 ; public FRigidbody3D player2 ; [Header(\"Start Positions\")] public FTransform ballStartPosition ; public FTransform player1StartPosition ; public FTransform player2StartPosition ; [Header(\"Scores\")] public int player1Score ; public int player2Score ; public void OnComputerUpdate ( FrameSyncGame game ) { float elapsed = ( float ) game . Elapsed (); int seconds = ( int ) elapsed ; int minutes = seconds / 60 ; seconds = seconds % 60 ; timeText . text = $ \"{minutes.ToString(\" 00 \")}:{seconds.ToString(\" 00 \")}\" ; player1Text . text = $ \"{player1Score}\" ; player2Text . text = $ \"{player2Score}\" ; } public void PlayerScored ( FrameSyncPlayer player ) { Debug . Log ( $ \"PlayerScored player={player.playerId}\" ); //update player scores if ( player . playerId == 1 ) { player1Score ++; } if ( player . playerId == 2 ) { player2Score ++; } ResetGame (); } void ResetGame () { ResetRigidbody ( ball , ballStartPosition ); ResetRigidbody ( player1 , player1StartPosition ); ResetRigidbody ( player2 , player2StartPosition ); } void ResetRigidbody ( FRigidbody3D fRigidbody3D , FTransform startPosition ) { fRigidbody3D . position = startPosition . position ; fRigidbody3D . rotation = startPosition . rotation ; fRigidbody3D . fTransform . Teleport ( startPosition . position ); fRigidbody3D . velocity = FVector3 . zero ; fRigidbody3D . angularVelocity = FVector3 . zero ; } } } Drag the Ball , and the Car s into the Rigidbodies fields. Create empty GameObjects at the starting positions of the Ball , and the Call s. Attach FTransform component to the empty GameObjects. Drag the empty GameObjects to the Start Positions fields.","title":"Reset to The Start Position"},{"location":"tutorial/Soccer/reset/#test","text":"Hit Play , you should see that the balls and the cars get reset to their starting positions.","title":"Test"},{"location":"tutorial/Soccer/setup/","text":"Set Up The Scene \u00b6 FPhysics3DManager \u00b6 For your first step, you will create a FPhysics3DManager . Right-Click in the Hierarchy window and select SocketWeaver->FPhysics->3D->Physics Controller . Make sure to disable Auto Initialize and Auto Update . Rigidbodies \u00b6 Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Cars Dynamic Controlled by players Arena Static Does not move Goals Static Do not move Arena \u00b6 Download the assets from our github repository. Drag the Arena 3D model to the SoccerGame scene. Move the Arena to (0, 0, 0). Add a FMeshCollider3D component to the Arena . A FTransform component should be automatically added. Add a FRigidbody3D component to the Arena and set its Body Type to Static . Ball \u00b6 Select SocketWeaver->FPhysics->3D->Sphere . Select the sphere and name it Ball . Move the Ball to (75, 1.5, 50). Set its scale to (3, 3, 3). Select the FSphereCollider component. Set Bounciness to 0.5. Enable Override Mass and set Custom Mass to 0.1. Cars \u00b6 In the FPhysics3D samples folder, select the Car prefab at Samples->3D->Scripts->Vehicle->SimpleRaycast . Drag it to the SoccerGame scene. Select the Car in the Hierarchy , right click and select Prefab->Unpack Completely . Move the Car to (85, 0.6, 50). Rotate the Car to (0, -90, 0). Goals \u00b6 Select SocketWeaver->FPhysics->3D->Cube . Select the cue and name it Goal . Move the Goal to (-8.4, 6, 50). Set its scale to (10, 12, 34). Select the FRigidbody3D of the Goal and set BodyType to Static . Select the FBoxCollider3D of the Goal and enable Is Trigger . Final Touch \u00b6 In the asset folder, we included the prototype textures pack from Kenney . You can select the textures you like and assign them to the materials of the Arena and the Ball . The scene should look like. Test \u00b6 Hit Play , you should be control the car using the WASD keys.","title":"Set Up The Scene"},{"location":"tutorial/Soccer/setup/#set-up-the-scene","text":"","title":"Set Up The Scene"},{"location":"tutorial/Soccer/setup/#fphysics3dmanager","text":"For your first step, you will create a FPhysics3DManager . Right-Click in the Hierarchy window and select SocketWeaver->FPhysics->3D->Physics Controller . Make sure to disable Auto Initialize and Auto Update .","title":"FPhysics3DManager"},{"location":"tutorial/Soccer/setup/#rigidbodies","text":"Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Cars Dynamic Controlled by players Arena Static Does not move Goals Static Do not move","title":"Rigidbodies"},{"location":"tutorial/Soccer/setup/#arena","text":"Download the assets from our github repository. Drag the Arena 3D model to the SoccerGame scene. Move the Arena to (0, 0, 0). Add a FMeshCollider3D component to the Arena . A FTransform component should be automatically added. Add a FRigidbody3D component to the Arena and set its Body Type to Static .","title":"Arena"},{"location":"tutorial/Soccer/setup/#ball","text":"Select SocketWeaver->FPhysics->3D->Sphere . Select the sphere and name it Ball . Move the Ball to (75, 1.5, 50). Set its scale to (3, 3, 3). Select the FSphereCollider component. Set Bounciness to 0.5. Enable Override Mass and set Custom Mass to 0.1.","title":"Ball"},{"location":"tutorial/Soccer/setup/#cars","text":"In the FPhysics3D samples folder, select the Car prefab at Samples->3D->Scripts->Vehicle->SimpleRaycast . Drag it to the SoccerGame scene. Select the Car in the Hierarchy , right click and select Prefab->Unpack Completely . Move the Car to (85, 0.6, 50). Rotate the Car to (0, -90, 0).","title":"Cars"},{"location":"tutorial/Soccer/setup/#goals","text":"Select SocketWeaver->FPhysics->3D->Cube . Select the cue and name it Goal . Move the Goal to (-8.4, 6, 50). Set its scale to (10, 12, 34). Select the FRigidbody3D of the Goal and set BodyType to Static . Select the FBoxCollider3D of the Goal and enable Is Trigger .","title":"Goals"},{"location":"tutorial/Soccer/setup/#final-touch","text":"In the asset folder, we included the prototype textures pack from Kenney . You can select the textures you like and assign them to the materials of the Arena and the Ball . The scene should look like.","title":"Final Touch"},{"location":"tutorial/Soccer/setup/#test","text":"Hit Play , you should be control the car using the WASD keys.","title":"Test"},{"location":"tutorial/Soccer/snapshot/","text":"Game States Snapshot \u00b6 In this seciton, you will take snapshots of the game states in your game to support running the game in the Prediction&Rollback mode. What Should Be Included in The Snapshot? \u00b6 All the game states that affect the game logic simulation result should be included in the snapshot. Let's look at the components in your game logic one by one to identify the states that should be add to the snapshot. External Game States : The rigidbodies physics states like position, rotation, linear velocity, angular velocity affects the simulation result. They should be included in the snapshot. You will use the FPhysics API to export the physics states. FrameSyncBehaviour States : SoccerVehicleController : The vehicle physics states are stored in the physics engine. The component itself is stateless. SoccerGoal : The trigger states: enter, stay, exit is stored in the physics engine. The component itself is stateless. SoccerGameFlow : The component is stateful. We should include the player scores, and the timer Id in the snapshot.","title":"Game States Snapshot"},{"location":"tutorial/Soccer/snapshot/#game-states-snapshot","text":"In this seciton, you will take snapshots of the game states in your game to support running the game in the Prediction&Rollback mode.","title":"Game States Snapshot"},{"location":"tutorial/Soccer/snapshot/#what-should-be-included-in-the-snapshot","text":"All the game states that affect the game logic simulation result should be included in the snapshot. Let's look at the components in your game logic one by one to identify the states that should be add to the snapshot. External Game States : The rigidbodies physics states like position, rotation, linear velocity, angular velocity affects the simulation result. They should be included in the snapshot. You will use the FPhysics API to export the physics states. FrameSyncBehaviour States : SoccerVehicleController : The vehicle physics states are stored in the physics engine. The component itself is stateless. SoccerGoal : The trigger states: enter, stay, exit is stored in the physics engine. The component itself is stateless. SoccerGameFlow : The component is stateful. We should include the player scores, and the timer Id in the snapshot.","title":"What Should Be Included in The Snapshot?"},{"location":"tutorial/pong/Rollback/","text":"Rollback \u00b6 You can adjust the ping value in the config.json file to simulate a bad internet connection. Set the ping to 150, it will inject a delay of 150ms to the packets sent between the debug server and the game clients. The RTT for the connections will be 300ms now. Play the game again, the input delay should be very noticeable. You'll add Rollback to your game to make it more responsive. IResotrable \u00b6 First, you will create a new class that implements IRestorable interface. A Rollback enabled game needs to rollback the game states to a confirmed frame from the server. The FrameSyncEngine will take care of the game states stored in the IFrameSyncData components. You need to provide the FrameSyncEngine with a IRestorable object to restore any states that are not stored in a IFrameSyncData component. C# public class MyRestorable : IRestorable { PSnapshot2D snapshot2D ; public int frameNumber { get ; } public MyRestorable ( int frameNumber ) { // 1 snapshot2D = Parallel2D . Snapshot (); this . frameNumber = frameNumber ; } public void Clear () { // 2 Parallel2D . DestroySnapshot ( snapshot2D ); } public void Restore () { // 3 Parallel2D . Restore ( snapshot2D ); } } In // 1 , you create a snapshot of the Parallel physics world. The created MyRestorable will be passed to the FrameSyncEngine. In // 2 , The FrameSyncEngine will call the Clear() method when it does not need to rollback to the frame for a IRestorable . You will destory the snapshot to free the memory in the Parallel physics world. In // 3 , The FrameSyncEngine will call the Restore() method when it wants to rollback to the frame for a IRestorable . You will use the snapshot to restore the physics state of the Parallel physics world. Next, add a public field rollback to the MyFrameSyncAgent script to enable/disable Rollback in the inspector. C# public bool rollback = false ; OnEngineWillExportEvent \u00b6 Make the following change to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); // 8 if ( rollback ) { engine . OnEngineWillExportEvent += FrameSyncEngineWillExport ; } } } In // 8 , we add our handler to the OnEngineWillExportEvent if rollback is enabled; C# IRestorable FrameSyncEngineWillExport ( int frameNumber ) { MyRestorable restorable = new MyRestorable ( frameNumber ); return restorable ; } You create an IRestorable in the event handler and returned it to the FrameSyncEngine. Enable Rollback \u00b6 Make the following change to the OnFrameSyncGameCreated method C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; // 8 game . clientSidePrediction = clientSidePrediction ; } } In // 8 , you enabled clientSidePrediction on your game. Play the game, the input delay should be reduced a lot now. Prediction Modifier \u00b6 You can use the Prediction Modifier to control the extrapolation for the other players. By default, the FrameSyncEngine just reuses the last received inputs to simulate other players for the prediction frames. Make the following change to the OnFrameSyncEngineCreated method. C# // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero , PredictionModifier ); In // 2 , you set the PredictionModifier method as the Prediction Modifier of the y input. C# Fix64 PredictionModifier ( Fix64 value ) { return value * Fix64 . half ; } The PredictionModifier method is very simply, the y input is decayed by 50%. The PredictionModifier method is called for every prediction frame, and the output of frame n will be used as the input for frame n+1 . So if the initial value of y is 1, the predicted values of y in the predicted frames will be 0.5 , 0.25 , 0.125 ...","title":"Rollback"},{"location":"tutorial/pong/Rollback/#rollback","text":"You can adjust the ping value in the config.json file to simulate a bad internet connection. Set the ping to 150, it will inject a delay of 150ms to the packets sent between the debug server and the game clients. The RTT for the connections will be 300ms now. Play the game again, the input delay should be very noticeable. You'll add Rollback to your game to make it more responsive.","title":"Rollback"},{"location":"tutorial/pong/Rollback/#iresotrable","text":"First, you will create a new class that implements IRestorable interface. A Rollback enabled game needs to rollback the game states to a confirmed frame from the server. The FrameSyncEngine will take care of the game states stored in the IFrameSyncData components. You need to provide the FrameSyncEngine with a IRestorable object to restore any states that are not stored in a IFrameSyncData component. C# public class MyRestorable : IRestorable { PSnapshot2D snapshot2D ; public int frameNumber { get ; } public MyRestorable ( int frameNumber ) { // 1 snapshot2D = Parallel2D . Snapshot (); this . frameNumber = frameNumber ; } public void Clear () { // 2 Parallel2D . DestroySnapshot ( snapshot2D ); } public void Restore () { // 3 Parallel2D . Restore ( snapshot2D ); } } In // 1 , you create a snapshot of the Parallel physics world. The created MyRestorable will be passed to the FrameSyncEngine. In // 2 , The FrameSyncEngine will call the Clear() method when it does not need to rollback to the frame for a IRestorable . You will destory the snapshot to free the memory in the Parallel physics world. In // 3 , The FrameSyncEngine will call the Restore() method when it wants to rollback to the frame for a IRestorable . You will use the snapshot to restore the physics state of the Parallel physics world. Next, add a public field rollback to the MyFrameSyncAgent script to enable/disable Rollback in the inspector. C# public bool rollback = false ;","title":"IResotrable"},{"location":"tutorial/pong/Rollback/#onenginewillexportevent","text":"Make the following change to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); // 8 if ( rollback ) { engine . OnEngineWillExportEvent += FrameSyncEngineWillExport ; } } } In // 8 , we add our handler to the OnEngineWillExportEvent if rollback is enabled; C# IRestorable FrameSyncEngineWillExport ( int frameNumber ) { MyRestorable restorable = new MyRestorable ( frameNumber ); return restorable ; } You create an IRestorable in the event handler and returned it to the FrameSyncEngine.","title":"OnEngineWillExportEvent"},{"location":"tutorial/pong/Rollback/#enable-rollback","text":"Make the following change to the OnFrameSyncGameCreated method C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; // 8 game . clientSidePrediction = clientSidePrediction ; } } In // 8 , you enabled clientSidePrediction on your game. Play the game, the input delay should be reduced a lot now.","title":"Enable Rollback"},{"location":"tutorial/pong/Rollback/#prediction-modifier","text":"You can use the Prediction Modifier to control the extrapolation for the other players. By default, the FrameSyncEngine just reuses the last received inputs to simulate other players for the prediction frames. Make the following change to the OnFrameSyncEngineCreated method. C# // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero , PredictionModifier ); In // 2 , you set the PredictionModifier method as the Prediction Modifier of the y input. C# Fix64 PredictionModifier ( Fix64 value ) { return value * Fix64 . half ; } The PredictionModifier method is very simply, the y input is decayed by 50%. The PredictionModifier method is called for every prediction frame, and the output of frame n will be used as the input for frame n+1 . So if the initial value of y is 1, the predicted values of y in the predicted frames will be 0.5 , 0.25 , 0.125 ...","title":"Prediction Modifier"},{"location":"tutorial/pong/ballManager/","text":"Ball Manager \u00b6 Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Kickoff \u00b6 The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball. Handle player ready input \u00b6 Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready. Boundary Check \u00b6 Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores. Reset the ball \u00b6 Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#ball-manager","text":"Next, you'll implment the game flow logic. Add a new script called BallManager to the Ball GameObject. Replace the content of the script with the following. Note that the BallManager implements the IFrameSyncData interface and the IFrameSyncUpdate interface. C# using System.Collections.Generic ; using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; using SWNetwork.Core ; public class BallManager : MonoBehaviour , IFrameSyncUpdate , IFrameSyncData { public bool player1Ready = false ; public bool player2Ready = false ; public int player1Score = 0 ; public int player2Score = 0 ; public Fix64 ballInitialSpeed = Fix64 . FromDivision ( 5 , 1 ); // reference to the ball's ParallelTransform component ParallelTransform parallelTransform ; // reference to the ball's ParallelRigidbody2D component ParallelRigidbody2D parallelRigidbody2D ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); parallelRigidbody2D = GetComponent < ParallelRigidbody2D >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Ball Manager"},{"location":"tutorial/pong/ballManager/#kickoff","text":"The Game starts when both player1 and player2 have pressed the ready button. Add the following methods to the BallManager script. C# public void PlayerIsReady ( PaddleOwnerData . PaddleOwner owner ) { // 1 if ( owner == PaddleOwnerData . PaddleOwner . Player1 ) { player1Ready = true ; } else { player2Ready = true ; } // 2 if ( player1Ready && player2Ready ) { Kickoff (); } } public void Kickoff () { // 3 Fix64 x = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); Fix64 y = FrameSyncRandom . Range ( Fix64 . NegOne , Fix64 . one ); // 4 Fix64Vec2 direction = new Fix64Vec2 ( x , y ); parallelRigidbody2D . LinearVelocity = direction . normalized * ballInitialSpeed ; } In // 1 , you set player1 and player2 ready based on the owner parameter. In // 2 , you fire the ball when both players are ready. In // 3 , you create two random numbers in range -1 to 1 using the FrameSyncRandom.Range method. The FrameSyncRandom class generates deterministic random numbers so players will get the same random numbers across the network. In // 4 , you use the random numbers to calculate the initial velocity of the ball.","title":"Kickoff"},{"location":"tutorial/pong/ballManager/#handle-player-ready-input","text":"Add the following to the PaddleUpdate script C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; // 3 if ( input . GetTriggerForPlayer ( \"ready\" , ownerData . player )) { BallManager ballManager = FindObjectOfType < BallManager >(); ballManager . PlayerIsReady ( ownerData . owner ); } } In // 3 , you read the ready input for the paddle owner player and tells the BallManager that the player is ready.","title":"Handle player ready input"},{"location":"tutorial/pong/ballManager/#boundary-check","text":"Add the following to the FrameSyncUpdate method in the BallManager script. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { //check boundary if ( parallelTransform . position . x < Fix64 . FromDivision (- 11 , 1 )) { //player 2 scored player2Score ++; ResetBall (); } else if ( parallelTransform . position . x > Fix64 . FromDivision ( 11 , 1 )) { //player 1 scored player1Score ++; ResetBall (); } } For every FrameSync frame, you check if the ball is out of the boundary. If the ball has passed the player1's paddle, player2 scores. If the ball passed the player2's paddle, player1 scores.","title":"Boundary Check"},{"location":"tutorial/pong/ballManager/#reset-the-ball","text":"Add a new method ResetBall C# public void ResetBall () { // 1 parallelTransform . position = Fix64Vec3 . zero ; parallelRigidbody2D . LinearVelocity = Fix64Vec2 . zero ; parallelRigidbody2D . AngularVelocity = Fix64 . zero ; // 2 player1Ready = false ; player2Ready = false ; } In // 1 , you reset ball's position and velocities. In // 2 , you reset players ready flag. So the players have to press the ready button again to continue.","title":"Reset the ball"},{"location":"tutorial/pong/buildGame/","text":"Building the Game \u00b6 64-bit architecture \u00b6 FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit. Windowed mode \u00b6 Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 . Entering the debug PlayerUID \u00b6 Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#building-the-game","text":"","title":"Building the Game"},{"location":"tutorial/pong/buildGame/#64-bit-architecture","text":"FrameSync only supports 64-bit systems. You'll go to File -> Build Settings and set Architecture to 64-bit.","title":"64-bit architecture"},{"location":"tutorial/pong/buildGame/#windowed-mode","text":"Next, go to Player Settings and set FullScreen Mode to Windowed . Also, set Default Screen Width to 1280 and Default Screen Hight to 720 .","title":"Windowed mode"},{"location":"tutorial/pong/buildGame/#entering-the-debug-playeruid","text":"Click on the Build button to build the game. You should see something like this once the game is launched. The debug server has playerUID 1 - 8 available to use, you can connect up to 8 players to it for testing. For this game, you will use playerUID of 1 and 2 since there are only 2 players. You can run one instance of the game using the built game client, and another one in the Unity Editor. The paddles and the ball should be synchronized.","title":"Entering the debug PlayerUID"},{"location":"tutorial/pong/collectInput/","text":"Collecting Player Inputs \u00b6 OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/collectInput/#collecting-player-inputs","text":"OnCollectLocalPlayerInputs Called every frame to collect the inputs of the local player. In OnCollectLocalPlayerInputs , you read player inputs from the Unity Input class and pass it to FrameSyncInput . Go to ProjectSettings->Input manager and add a new input Vertical1 . You can Right-Click the input Vertical and Duplicate Array Element to copy the input settings. Set Negative Button to down and Positive Button to up for the new input. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } In // 1 , player1 uses w and s to move and uses g to trigger the ready input. In // 2 , player2 uses up arrow and down arrow to move and uses h to trigger the ready input.","title":"Collecting Player Inputs"},{"location":"tutorial/pong/configEngine/","text":"Configuring the FrameSyncEngine \u00b6 OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring FrameSyncEngine"},{"location":"tutorial/pong/configEngine/#configuring-the-framesyncengine","text":"OnFrameSyncEngineCreated(FrameSyncEngine engine) Called after the FrameSyncAgent created its FrameSyncEngine in the Awake() method. In OnFrameSyncEngineCreated , you tell the FrameSyncEngine what the inputs are used in your game. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; } void FrameSyncEngineWillSimulate () { // 7 parallelPhysics . Step ( FrameSyncTime . fixedDeltaTime ); } In // 1 , you create an array of input settings, the game uses 2 inputs, so the array size is 2. In // 2 , the first input is a CompressedFloatInput . it contains the information of the vertical axis from the keyboard. you will feed player's input to it later when we implement the OnCollectLocalPlayerInputs method. In // 3 , the second input is a TriggerInput , players will trigger this input when they are ready to play the game. In // 4 , you use the input settings array to create an inputConfig and you pass it to the FrameSyncEngine using the SetFrameSyncInputConfig method. In // 5 , you find the ParallelPhysicsController2D object of the scene and disabled autoUpdate . You'll manually call the Step() method of the ParallelPhysicsController2D object to simulate the physics in your game. In // 6 , you subscribe to the OnEngineWillSimulateEvent . In // 7 , you simulate physics manually in the OnEngineWillSimulate event handler.","title":"Configuring the FrameSyncEngine"},{"location":"tutorial/pong/configGame/","text":"Configuring the FrameSyncGame \u00b6 OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring FrameSyncGame"},{"location":"tutorial/pong/configGame/#configuring-the-framesyncgame","text":"OnFrameSyncGameCreated Called after the FrameSyncAgent created its FrameSyncGame in the Awake() method. In OnFrameSyncGameCreated , you create the players and set the game custom data of your game. C# public class MyGameSettings { public byte player1ID ; public byte player2ID ; } You will use MyGameSettings as the custom data of your game. In online mode, game custom data is configured in the matchmaking stage before creating the FrameSyncAgent . For now, you will hardcode it to run the game offline. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } In // 1 , you set the game type to offline. In // 2 , you created two offline players. In // 3 , you created a MyGameSettings object and set its playerIDs to the offline players you just created in // 2 . In // 4 , you passed the MyGameSettings Object created in // 3 to the FrameSyncGame .","title":"Configuring the FrameSyncGame"},{"location":"tutorial/pong/connectToDebugServer/","text":"Connecting to the Debug Server \u00b6 Start scene \u00b6 You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build. Adding UI elements \u00b6 You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection MyGameServerConnection \u00b6 Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"Connecting to Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#connecting-to-the-debug-server","text":"","title":"Connecting to the Debug Server"},{"location":"tutorial/pong/connectToDebugServer/#start-scene","text":"You'll create a new scene for creating the connection with the debug game server. Create a new scene and change its name to Start as it will be the first scene that players see when game starts. Open the Build Settings and add the Start scene to the build.","title":"Start scene"},{"location":"tutorial/pong/connectToDebugServer/#adding-ui-elements","text":"You just need to add two UI elements for this game. Name Type Description PlayerUIDInputField InputField To enter the playerUID ConnectButton Button To Start the connection","title":"Adding UI elements"},{"location":"tutorial/pong/connectToDebugServer/#mygameserverconnection","text":"Next, create a new empty GameObject and name it MyGameServerConnection . Create a new script MyGameServerConnection.cs and attach it to the MyGameServerConnection GameObject. Replace the code in the script with the following. C# using SWNetwork.FrameSync ; using System.Collections ; using System.Collections.Generic ; using UnityEngine ; using UnityEngine.SceneManagement ; using UnityEngine.UI ; public class MyGameServerConnection : MonoBehaviour { /// <summary> /// InputField for entering the playerUID /// </summary> public InputField playerUIDField ; public void Connect () { string playerUID = playerUIDField . text ; Debug . Log ( $ \"Connecting.. {playerUID}\" ); if ( playerUID != null && playerUID . Length > 0 ) { // 1 FrameSyncClient . InitDebugMode ( playerUID , 2 ); // 2 FrameSyncClient . ConnectDebugServer ( \"127.0.0.1\" , ready => { Debug . Log ( $ \"OnClientReady {ready}\" ); if ( ready ) { // 3 SceneManager . LoadScene ( \"Pong\" ); } }); } else { Debug . LogError ( \"Please Enter a playerID\" ); } } } In // 1 , To test your game with the debug server. You used InitDebugMode method to initialize the FrameSyncClient . There are two players in the game, so you set the playerCount of the FrameSyncClient to 2. In // 2 , you call the ConnectToDebugServer method to start the connection with the debug server on the local machine. In // 3 , you load the pong scene if the connection is established. Next, you'll connect the UI elements and the script. Drag the PlayerUIDInputField to the MyGameServerConnection component. Select the Connect() method of the MyGameServerConnection component to handle the OnClick event of the connect button.","title":"MyGameServerConnection"},{"location":"tutorial/pong/createAgent/","text":"Creating FrameSyncAgent \u00b6 You will create an empty GameObject to house your customized FrameSyncAgent . MyFrameSyncAgent \u00b6 Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#creating-framesyncagent","text":"You will create an empty GameObject to house your customized FrameSyncAgent .","title":"Creating FrameSyncAgent"},{"location":"tutorial/pong/createAgent/#myframesyncagent","text":"Next, create a new script MyFrameSyncAgent and attach it to the empty GameObject by selecting Add Componnet . Remove the Start() and Update() methods and add the following to the MyFrameSyncAgent script. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class MyFrameSyncAgent : FrameSyncAgent { // offline players public FrameSyncPlayer player1 ; public FrameSyncPlayer player2 ; // physics controller of the scene ParallelPhysicsController2D parallelPhysics ; public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { } public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { } public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { } }","title":"MyFrameSyncAgent"},{"location":"tutorial/pong/debugServer/","text":"Debug Server \u00b6 FrameSync comes with a debug server that helps you test and debug your game on your local machines. Install \u00b6 You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer Launch the server \u00b6 Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#debug-server","text":"FrameSync comes with a debug server that helps you test and debug your game on your local machines.","title":"Debug Server"},{"location":"tutorial/pong/debugServer/#install","text":"You can download the debug server from our github page. https://github.com/shuningzhou/FrameSyncDebugServer","title":"Install"},{"location":"tutorial/pong/debugServer/#launch-the-server","text":"Double Click the debugserver application in the bin folder to launch the debug server. You should see something like the following in the terminal. Minimize the terminal to keep the server running. Now, you can open your browser and visit the debug server at localhost:2020 . You should see something like the following in the browser.","title":"Launch the server"},{"location":"tutorial/pong/offline/","text":"Playing Offline \u00b6 Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/offline/#playing-offline","text":"Before playing the game, you need to set the gravity of the game to zero. Select the ParallelPhysicsController2D component and setting its Gravity to (0,0) . After that, you can remove the friction of the walls by selecting the ParallelBoxCollider components of the them and setting their Friction value to 0 . Also, you can set Bounciness value of the colliders in the scene to 1 to make them bouncy. Now, you are ready to play the game in the offline mode. Just hit play. You should be able to move the paddles with the w , s keys or with the arrow keys. To start the match, you can press g to make player1 ready, and press h to make player2 ready.","title":"Playing Offline"},{"location":"tutorial/pong/online/","text":"Online FrameSyncAgent \u00b6 You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field offline to the MyFrameSyncAgent script to control online/offline mode in the inspector C# public bool offline = false ; Updating the OnFrameSyncEngineCreated method \u00b6 Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } } Updating the OnFrameSyncGameCreated method \u00b6 Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing. Updating the OnCollectLocalPlayerInputs method \u00b6 Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#online-framesyncagent","text":"You'll modify the MyFrameSyncAgent script to support playing the game online. First, add a public field offline to the MyFrameSyncAgent script to control online/offline mode in the inspector C# public bool offline = false ;","title":"Online FrameSyncAgent"},{"location":"tutorial/pong/online/#updating-the-onframesyncenginecreated-method","text":"Next, you'll configure the networking input/output of the engine by adding // 7 to the OnFrameSyncEngineCreated method. C# public override void OnFrameSyncEngineCreated ( FrameSyncEngine engine ) { // 1 FrameSyncInputSetting [] inputSettings = new FrameSyncInputSetting [ 2 ]; // 2 inputSettings [ 0 ] = FrameSyncInputSetting . CompressedFloatInput ( \"y\" , Fix64 . FromDivision (- 1 , 1 ), Fix64 . FromDivision ( 1 , 1 ), Fix64 . FromDivision ( 1 , 10 ), Fix64 . zero ); // 3 inputSettings [ 1 ] = FrameSyncInputSetting . TriggerInput ( \"ready\" ); // 4 FrameSyncInputConfig inputConfig = new FrameSyncInputConfig ( inputSettings ); engine . SetFrameSyncInputConfig ( inputConfig ); // 5 parallelPhysics = FindObjectOfType < ParallelPhysicsController2D >(); parallelPhysics . autoUpdate = false ; // 6 engine . OnEngineWillSimulateEvent += FrameSyncEngineWillSimulate ; // 7 if (! offline ) { engine . SetNetworkIO ( FrameSyncClient . Instance . frameSyncIO ); } }","title":"Updating the OnFrameSyncEngineCreated method"},{"location":"tutorial/pong/online/#updating-the-onframesyncgamecreated-method","text":"Replace the content of the OnFrameSyncGameCreated method with the following. C# public override void OnFrameSyncGameCreated ( FrameSyncGame game , FrameSyncReplay replay ) { if ( offline ) { // 1 game . type = FrameSyncGameType . Offline ; // 2 player1 = game . CreateOfflineGamePlayer (); player2 = game . CreateOfflineGamePlayer (); // 3 MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = player1 . PlayerID ; gameSettings . player2ID = player2 . PlayerID ; // 4 game . userData = gameSettings ; } else { // 5 game . type = FrameSyncGameType . Online ; // 6 game . SetPlayerDataProvider ( FrameSyncClient . Instance . playerDataProvider ); game . CreateOnlinePlayers (); // 7 game . CreateGameUserData < MyGameSettings >(); //todo: game settings will be created in the matchmaking stage MyGameSettings gameSettings = new MyGameSettings (); gameSettings . player1ID = 1 ; gameSettings . player2ID = 2 ; game . userData = gameSettings ; } } In // 5 , you set the game type to Online . In // 6 , you create the online players by setting the PlayerDataProvider of the game and calling the CreateOnlinePlayers method. In // 7 , you create the userData of the game. the userData is hardcoded for now for testing.","title":"Updating the OnFrameSyncGameCreated method"},{"location":"tutorial/pong/online/#updating-the-oncollectlocalplayerinputs-method","text":"Replace the content of the OnCollectLocalPlayerInputs method with the following. C# public override void OnCollectLocalPlayerInputs ( FrameSyncInput input , FrameSyncGame game ) { if ( offline ) { // 1 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), player1 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), player1 ); // 2 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical1\" ), player2 ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . H ), player2 ); } else { // 3 input . SetFloatForPlayer ( \"y\" , ( Fix64 ) Input . GetAxis ( \"Vertical\" ), game . localPlayer ); input . SetTriggerForPlayer ( \"ready\" , Input . GetKeyUp ( KeyCode . G ), game . localPlayer ); } } In // 3 , collect input values of the up arrow , down arrow , and g keys for the local player.","title":"Updating the OnCollectLocalPlayerInputs method"},{"location":"tutorial/pong/overview/","text":"","title":"Overview"},{"location":"tutorial/pong/paddleMovement/","text":"Paddle Movement \u00b6 Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } } FrameSyncUpdate \u00b6 Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#paddle-movement","text":"Next, you'll implement the paddle movement logic. Add a new script called PaddleUpdate to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleUpdate implements the IFrameSyncUpdate interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using Parallel ; public class PaddleUpdate : MonoBehaviour , IFrameSyncUpdate { // movement speed of the paddle public Fix64 speed = Fix64 . FromDivision ( 5 , 1 ); // reference to the PaddleOwnerData component PaddleOwnerData ownerData ; // reference to the ParallelTransform component ParallelTransform parallelTransform ; public void Awake () { ownerData = GetComponent < PaddleOwnerData >(); parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { } }","title":"Paddle Movement"},{"location":"tutorial/pong/paddleMovement/#framesyncupdate","text":"Add the following to the FrameSyncUpdate method. C# public void FrameSyncUpdate ( FrameSyncInput input , FrameSyncUpdateType frameSyncUpdateType ) { // 1 Fix64 y = input . GetFloatForPlayer ( \"y\" , ownerData . player ); // 2 Fix64Vec3 displacement = speed * FrameSyncTime . fixedDeltaTime * new Fix64Vec3 ( Fix64 . zero , y , Fix64 . zero ); parallelTransform . position += displacement ; } In // 1 , you read the y input of the paddle owner player. In // 2 , you calculate the displacement for the frame and update the position of the paddle.","title":"FrameSyncUpdate"},{"location":"tutorial/pong/paddleOwner/","text":"Paddle Owner \u00b6 Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } FrameSyncDataInitialize \u00b6 The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#paddle-owner","text":"Before implementing the paddle movement logic, you need to assign the paddles to the players. Do this by adding a new script called PaddleOwnerData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddleOwnerData implements the IFrameSyncData interface. C# using SWNetwork.Core ; using SWNetwork.FrameSync ; using System.Collections.Generic ; using UnityEngine ; public class PaddleOwnerData : MonoBehaviour , IFrameSyncData { public enum PaddleOwner { Player1 , Player2 } // set in the inspector public PaddleOwner owner ; // reference to the FrameSyncPlayer // set when initializing the FrameSyncData // made public so other component can get the own player // through the PaddleOwnerData component public FrameSyncPlayer player ; public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Export ( SWBytes buffer ) { } public void Import ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Owner"},{"location":"tutorial/pong/paddleOwner/#framesyncdatainitialize","text":"The FrameSyncDataInitialize method is called before the first FrameSyncUpdate() call to the GameObject. You'll implement the logic to assign paddles to their owners in it. C# public void FrameSyncDataInitialize ( FrameSyncGame game ) { // 1 MyGameSettings gameSettings = game . userData as MyGameSettings ; // 2 if ( owner == PaddleOwner . Player1 ) { player = game . GetPlayer ( gameSettings . player1ID ); } else { player = game . GetPlayer ( gameSettings . player2ID ); } } In // 1 , you get the custom data of the game. In // 2 , you use the playerIDs of custom data and the owner field of the script to get the FrameSyncPlayers . You'll use the FrameSyncPlayers to read their inputs. Info The owner field is set in the inspector and should never change. We can leave the Export , Import , and the ExportDebugInfo method empty. In the Inspector window, click the Overrides button to add the PaddleOwnerData script to the other paddle in the scene. Assign the other paddle to player2 by setting its owner to Player 2 . Now you should have 1 paddle for Player 1 and 1 paddle for Player 2 .","title":"FrameSyncDataInitialize"},{"location":"tutorial/pong/paddlePosition/","text":"Paddle Position Data \u00b6 Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } } Importing \u00b6 Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value. Exporting \u00b6 Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#paddle-position-data","text":"Next, you'll export the paddle position data. The paddle position should be exported and uploaded to the game server for validation. Add a new script called PaddlePositionData to the Paddle GameObject. Replace the content of the script with the following. Note that the PaddlePositionData implements the IFrameSyncData interface. C# using UnityEngine ; using SWNetwork.FrameSync ; using SWNetwork.Core ; using System.Collections.Generic ; using Parallel ; public class PaddlePositionData : MonoBehaviour , IFrameSyncData { // reference to the PaddleOwnerData component ParallelTransform parallelTransform ; public void Awake () { parallelTransform = GetComponent < ParallelTransform >(); } public void FrameSyncDataInitialize ( FrameSyncGame game ) { } public void Import ( SWBytes buffer ) { } public void Export ( SWBytes buffer ) { } public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { } }","title":"Paddle Position Data"},{"location":"tutorial/pong/paddlePosition/#importing","text":"Add the following to the Import methods. C# public void Import ( SWBytes buffer ) { // 1 long y = buffer . PopLong (); Fix64 fy = Fix64 . FromRaw ( y ); // 2 parallelTransform . position = new Fix64Vec3 ( parallelTransform . position . x , fy , parallelTransform . position . z ); } In // 1 , you pop the y position value from the buffer. In // 2 , you restore the paddle position to the y position value.","title":"Importing"},{"location":"tutorial/pong/paddlePosition/#exporting","text":"Add the following to the Export methods. C# public void Export ( SWBytes buffer ) { // 1 buffer . Push ( parallelTransform . position . y . Raw ); } In // 1 , you push the y position value to the buffer. Info The ExportDebugInfo method is left empty. It is only used when you are debugging the game with a local dev server.","title":"Exporting"},{"location":"tutorial/pong/parallel2d/","text":"Physics 2D \u00b6 FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller . Rigidbodies \u00b6 Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move Creating the ball \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject. Creating the paddles \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) . Creating the walls \u00b6 Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) . Setting up the camera \u00b6 Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 . Final touch \u00b6 You can change the color of the sprite to your liking. The scene should look like.","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#physics-2d","text":"FrameSync comes with a built-in physics engine to help you simulate physics in your game. In this tutorial, you are going to use the build-in 2D physics to simulate the ball's movment. For your first step, you will create a 2D Physics Controller. Right-Click in the Hierarchy window and select Parallel -> 2D -> Physics Controller .","title":"Physics 2D"},{"location":"tutorial/pong/parallel2d/#rigidbodies","text":"Next, you will create the following Rigidbodies. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move","title":"Rigidbodies"},{"location":"tutorial/pong/parallel2d/#creating-the-ball","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Ball . Create a circle sprite by selecting Create -> Sprites -> Circle in the Project windows. Assign the circle sprite to the Ball 2D GameObject. Reset the Transform component of the Ball GameObject to make sure it is positioned at (0 ,0, 0) . Add a ParallelRigidbody2D componenet to the Ball GameObject. Add a ParallelCircleCollider componenet to the Ball GameObject.","title":"Creating the ball"},{"location":"tutorial/pong/parallel2d/#creating-the-paddles","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Paddle . Create a box sprite by selecting Create -> Sprites -> Square in the Project windows. Assign the box sprite to the Paddle GameObject. Move the Paddle to (-10, 0, 0) . Set the Scale of Paddle to (1, 3, 1) . Add a ParallelRigidbody2D componenet to the Paddle GameObject. Add a ParallelBoxCollider componenet to the Paddle GameObject. Set Body Type of the ParallelRigidbody2D component to Kinematic . Drag the Paddle to the Project window to make it a prefab and make another Paddle at (10, 0, 0) .","title":"Creating the paddles"},{"location":"tutorial/pong/parallel2d/#creating-the-walls","text":"Create a 2D Sprite GameObject by selecting 2D Object -> Sprite and name it Wall . Assign the box sprite to the Wall GameObject. Move the Wall to (0, 5, 0) . Set the Scale of Wall to (21, 1, 1) . Add a ParallelRigidbody2D componenet to the Wall GameObject. Add a ParallelBoxCollider componenet to the Wall GameObject. Set Body Type of the ParallelRigidbody2D component to Static . Duplicate the Wall and place the duplicated Wall (1) at (0, -5, 0) .","title":"Creating the walls"},{"location":"tutorial/pong/parallel2d/#setting-up-the-camera","text":"Set clear Flags of the Main Camera to Solid Color . Set Background of the Main Camera to black. Set Aspect ratio of the Game window to 16:9 .","title":"Setting up the camera"},{"location":"tutorial/pong/parallel2d/#final-touch","text":"You can change the color of the sprite to your liking. The scene should look like.","title":"Final touch"},{"location":"tutorial/pong/staticFrameSyncBehaviour/","text":"StaticFrameSyncBehaviour \u00b6 FrameSync managed updates \u00b6 StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method. FrameSync managed data \u00b6 When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data. Which GameObject should have a StaticFrameSyncBehaviour? \u00b6 You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them. Adding the StaticFrameSyncBehaviour componennt \u00b6 Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour . Assign the StaticFrameSyncBehaviourID \u00b6 You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#staticframesyncbehaviour","text":"","title":"StaticFrameSyncBehaviour"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-updates","text":"StaticFrameSyncBehaviour registers its GameObject to the FrameSyncEngine. When the FrameSyncEngine simulates a frame, it prepares the player inputs for the frame and notifies all the registered StaticFrameSyncBehaviour s to update. When a StaticFrameSyncBehaviour got notified about the simulation, it excutes the FrameSyncUpdate() method of the IFrameSyncUpdate MonoBehaviour components of its GameObject. Info You can think of FrameSyncUpdate() as the FrameSync version of the Unity Update() . It is called every FrameSync frame. Your behaviour and logic should be excuted in the FrameSyncUpdate() method.","title":"FrameSync managed updates"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#framesync-managed-data","text":"When the FrameSyncEngine finished simulating a frame, it notifies all the registered StaticFrameSyncBehaviour s to export their data. The exported data is used for the FrameSync consensus mechanism to achieve the agreement on the simulation results among different players across the network. When a StaticFrameSyncBehaviour is asked to export its data, it excutes the Export() method of the IFrameSyncData MonoBehaviour components of its GameObject. When a StaticFrameSyncBehaviour is asked to restore to a frame, it excutes the Import() method of the IFrameSyncData MonoBehaviour components of its GameObject with the saved data.","title":"FrameSync managed data"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#which-gameobject-should-have-a-staticframesyncbehaviour","text":"You have the following Rigidbodies active in the game. Name Body Type Description Ball Dynamic Controlled by physics Paddles Kinematic Controlled by players Walls Staic Do not move For the Paddles, they read player inputs to move and their position information should be exported, so we should add StaticFrameSyncBehaviour to them. For the Ball, it does boundary check every frame and its position information should be exported, so it should have a StaticFrameSyncBehaviour . For the Walls, they do not move and their physical data does not change so we do not need to add StaticFrameSyncBehaviour to them.","title":"Which GameObject should have a StaticFrameSyncBehaviour?"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#adding-the-staticframesyncbehaviour-componennt","text":"Select the Ball and the Paddle s in the Hierarchy window and add StaticFrameSyncBehaviour to them by selecting Add Component -> Static Frame Sync Behaviour .","title":"Adding the StaticFrameSyncBehaviour componennt"},{"location":"tutorial/pong/staticFrameSyncBehaviour/#assign-the-staticframesyncbehaviourid","text":"You need to assign different StaticFrameSyncBehaviourID to the StaticFrameSyncBehaviour in your scene. Name StaticFrameSyncBehaviourID Ball 1 Paddle for player 1 2 Paddle for player 2 3","title":"Assign the StaticFrameSyncBehaviourID"},{"location":"tutorial/pong/viewFrame/","text":"Frame Information \u00b6 The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods. Export frame info for PaddlePositionData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); } Export frame info for PaddleOwnerData \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); } Export frame info for BallManager \u00b6 C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); } Reset the debug server \u00b6 You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#frame-information","text":"The frame information is exported from the game clients and displayed on the debug server. You can see in the screenshot that both player1's game and player2's game generated the same simulation result hash for frame 263. That means the simulation results are identical. In the Input tab, you can view the Input values used in the game clients for frame 263. In the Static Behaviours tab, you can view the data of the static behaviours. There are no data displayed here at the moment because we left the ExportDebugInfo methods empty. Add the following to the ExportDebugInfo methods.","title":"Frame Information"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddlepositiondata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"x\" ] = parallelTransform . position . x . ToString (); debugDictionary [ \"y\" ] = parallelTransform . position . y . ToString (); }","title":"Export frame info for PaddlePositionData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-paddleownerdata","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"owner\" ] = owner . ToString (); }","title":"Export frame info for PaddleOwnerData"},{"location":"tutorial/pong/viewFrame/#export-frame-info-for-ballmanager","text":"C# public void ExportDebugInfo ( Dictionary < string , string > debugDictionary ) { debugDictionary [ \"player1Ready\" ] = player1Ready . ToString (); debugDictionary [ \"player2Ready\" ] = player2Ready . ToString (); debugDictionary [ \"player1Score\" ] = player1Score . ToString (); debugDictionary [ \"player2Score\" ] = player2Score . ToString (); debugDictionary [ \"ballPosition\" ] = parallelTransform . position . ToString (); debugDictionary [ \"Velocity\" ] = parallelRigidbody2D . LinearVelocity . ToString (); debugDictionary [ \"AngularVelocity\" ] = parallelRigidbody2D . AngularVelocity . ToString (); }","title":"Export frame info for BallManager"},{"location":"tutorial/pong/viewFrame/#reset-the-debug-server","text":"You need to click the Reset Server button at the top right corner of the debug server page to reset the debug server. It will clear the debug frame information for the last game and prepare the server for you to connect again. Build and play the game. You should see something like this in the Static Behaviours tab.","title":"Reset the debug server"}]}